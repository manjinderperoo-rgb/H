import makeWASocket, { useMultiFileAuthState, DisconnectReason, delay, fetchLatestBaileysVersion, Browsers, downloadMediaMessage, generateWAMessageFromContent, proto } from '@whiskeysockets/baileys';
import { Boom } from '@hapi/boom';
import pino from 'pino';
import fs from 'fs';
import readline from 'readline';
import gtts from 'node-gtts';

const ROLES_FILE = './data/roles.json';
const BOTS_FILE = './data/bots.json';
const DELAYS_FILE = './data/ncDelays.json';

const defaultRoles = {
    admins: [],
    subAdmins: {}
};

const defaultDelays = {
    // Individual NC delays
    nc1: 200, nc2: 200, nc3: 200, nc4: 200, nc5: 200,
    nc6: 200, nc7: 200, nc8: 200, nc9: 200, nc10: 200,
    nc11: 200, nc12: 200, nc13: 200, nc14: 200, nc15: 200,
    nc16: 200, nc17: 200, nc18: 200, nc19: 200, nc20: 200,
    nc21: 200, nc22: 200, nc23: 200, nc24: 200, nc25: 200,
    nc26: 200, nc27: 200, nc28: 200, nc29: 200, nc30: 200,
    nc31: 200, nc32: 200, nc33: 200, nc34: 200, nc35: 200,
    nc36: 200, nc37: 200, nc38: 200, nc39: 200, nc40: 200,
    nc41: 200, nc42: 200, nc43: 200, nc44: 200, nc45: 200,
    nc46: 200, nc47: 200, nc48: 200, nc49: 200, nc50: 200,
    nc51: 200, nc52: 200, nc53: 200, nc54: 200, nc55: 200,
    nc56: 200, nc57: 200, nc58: 200, nc59: 200, nc60: 200,
    nc61: 200, nc62: 200, nc63: 200, nc64: 200, nc65: 200,
    nc66: 200, nc67: 200, nc68: 200, nc69: 200, nc70: 200,
    nc71: 200, nc72: 200, nc73: 200, nc74: 200, nc75: 200,
    nc76: 200, nc77: 200, nc78: 200, nc79: 200, nc80: 200,
    nc81: 200, nc82: 200, nc83: 200, nc84: 200, nc85: 200,
    nc86: 200, nc87: 200, nc88: 200, nc89: 200, nc90: 200,
    nc91: 200, nc92: 200, nc93: 200, nc94: 200, nc95: 200,
    nc96: 200, nc97: 200, nc98: 200, nc99: 200, nc100: 200,
    
    // Triple attack delays
    triple1: 200, triple2: 200, triple3: 200, triple4: 200, triple5: 200,
    triple6: 200, triple7: 200, triple8: 200, triple9: 200, triple10: 200,
    triple11: 200, triple12: 200, triple13: 200, triple14: 200, triple15: 200,
    triple16: 200, triple17: 200, triple18: 200, triple19: 200, triple20: 200,
    triple21: 200, triple22: 200, triple23: 200, triple24: 200, triple25: 200,
    triple26: 200, triple27: 200, triple28: 200, triple29: 200, triple30: 200,
    triple31: 200, triple32: 200, triple33: 200, triple34: 200, triple35: 200
};

// Minimum safe delays (for warning)
const MINIMUM_SAFE_DELAYS = {
    nc_attacks: 1000,
    messages: 1500,
    voice: 2000,
    group_changes: 5000,
    triple_nc: 500
};

function loadRoles() {
    try {
        if (fs.existsSync(ROLES_FILE)) {
            const data = fs.readFileSync(ROLES_FILE, 'utf8');
            return JSON.parse(data);
        }
    } catch (err) {
        console.log('[ROLES] Error loading roles, using defaults');
    }
    return { ...defaultRoles };
}

function saveRoles(roles) {
    try {
        if (!fs.existsSync('./data')) {
            fs.mkdirSync('./data', { recursive: true });
        }
        fs.writeFileSync(ROLES_FILE, JSON.stringify(roles, null, 2));
    } catch (err) {
        console.error('[ROLES] Error saving roles:', err.message);
    }
}

function loadDelays() {
    try {
        if (fs.existsSync(DELAYS_FILE)) {
            const data = fs.readFileSync(DELAYS_FILE, 'utf8');
            const loadedDelays = { ...defaultDelays, ...JSON.parse(data) };
            
            // Check for dangerously low delays and warn
            for (const [key, value] of Object.entries(loadedDelays)) {
                if (key.startsWith('triple') && value < MINIMUM_SAFE_DELAYS.triple_nc) {
                    console.warn(`‚ö†Ô∏è  WARNING: ${key} delay is set to ${value}ms (RISKY - Minimum recommended: ${MINIMUM_SAFE_DELAYS.triple_nc}ms)`);
                } else if (key.startsWith('nc') && value < MINIMUM_SAFE_DELAYS.nc_attacks) {
                    console.warn(`‚ö†Ô∏è  WARNING: ${key} delay is set to ${value}ms (RISKY - Minimum recommended: ${MINIMUM_SAFE_DELAYS.nc_attacks}ms)`);
                }
            }
            
            return loadedDelays;
        }
    } catch (err) {
        console.log('[DELAYS] Error loading delays, using defaults');
    }
    return { ...defaultDelays };
}

function saveDelays(delays) {
    try {
        if (!fs.existsSync('./data')) {
            fs.mkdirSync('./data', { recursive: true });
        }
        fs.writeFileSync(DELAYS_FILE, JSON.stringify(delays, null, 2));
    } catch (err) {
        console.error('[DELAYS] Error saving delays:', err.message);
    }
}

let roles = loadRoles();
let ncDelays = loadDelays();

function isAdmin(jid) {
    return roles.admins.includes(jid);
}

function isSubAdmin(jid, groupJid) {
    return roles.subAdmins[groupJid]?.includes(jid) || false;
}

function hasPermission(jid, groupJid) {
    return isAdmin(jid) || isSubAdmin(jid, groupJid);
}

function addAdmin(jid) {
    if (!roles.admins.includes(jid)) {
        roles.admins.push(jid);
        saveRoles(roles);
        return true;
    }
    return false;
}

function removeAdmin(jid) {
    const index = roles.admins.indexOf(jid);
    if (index > -1) {
        roles.admins.splice(index, 1);
        saveRoles(roles);
        return true;
    }
    return false;
}

function addSubAdmin(jid, groupJid) {
    if (!roles.subAdmins[groupJid]) {
        roles.subAdmins[groupJid] = [];
    }
    if (!roles.subAdmins[groupJid].includes(jid)) {
        roles.subAdmins[groupJid].push(jid);
        saveRoles(roles);
        return true;
    }
    return false;
}

function removeSubAdmin(jid, groupJid) {
    if (roles.subAdmins[groupJid]) {
        const index = roles.subAdmins[groupJid].indexOf(jid);
        if (index > -1) {
            roles.subAdmins[groupJid].splice(index, 1);
            saveRoles(roles);
            return true;
        }
    }
    return false;
}

// ========== EMOJI ARRAYS ==========
const emojiArrays = {
    // FACE EMOJIS (1-10)
    nc1: ['üòÄ','üòÉ','üòÑ','üòÅ','üòÜ','üòÖ','üòÇ','ü§£','üòä','üòá','üôÇ','üôÉ'],
    nc2: ['üòâ','üòå','üòç','ü•∞','üòò','üòó','üòô','üòö','üòã','üòõ','üòù','üòú'],
    nc3: ['ü§™','üòé','ü•∏','ü§ì','üßê','ü§Ø','ü•≥','üòè','üòí','üòû','üòî','üòü'],
    nc4: ['üòï','üôÅ','‚òπÔ∏è','üò£','üòñ','üò´','üò©','ü•∫','üò¢','üò≠','üò§','üò†'],
    nc5: ['üò°','ü§¨','ü§Ø','üò≥','ü•µ','ü•∂','üò±','üò®','üò∞','üò•','üòì','ü§ó'],
    nc6: ['ü§î','ü´£','ü§≠','ü§´','ü§•','üò∂','ü´•','üòê','ü´§','üòë','üò¨','ü´®'],
    nc7: ['üôÑ','üòØ','üò¶','üòß','üòÆ','üò≤','ü•±','üò¥','ü§§','üò™','üòµ','ü§ê'],
    nc8: ['ü•¥','üò∑','ü§í','ü§ï','ü§¢','ü§Æ','ü§ß','üòá','ü•≥','ü•∏','üòà','üëø'],
    nc9: ['üëπ','üë∫','ü§°','üí©','üëª','üíÄ','‚ò†Ô∏è','üëΩ','üëæ','ü§ñ','üéÉ','üò∫'],
    nc10: ['üò∏','üòπ','üòª','üòº','üòΩ','üôÄ','üòø','üòæ','üëã','ü§ö','üñêÔ∏è','‚úã'],
    
    // HAND GESTURES (11-20)
    nc11: ['üññ','üëå','ü§å','ü§è','‚úåÔ∏è','ü§û','ü´∞','ü§ü','ü§ò','ü§ô','ü´µ','ü´≤'],
    nc12: ['ü´≥','üëà','üëâ','üëÜ','üñï','üëá','‚òùÔ∏è','üëç','üëé','‚úä','üëä','ü§õ'],
    nc13: ['ü§ú','üëè','üôå','ü´∂','üëê','ü§≤','ü§ù','üôè','‚úçÔ∏è','üíÖ','ü§≥','üí™'],
    nc14: ['ü¶æ','ü¶ø','ü¶µ','ü¶∂','üëÇ','ü¶ª','üëÉ','üß†','ü´Ä','ü´Å','ü¶∑','ü¶¥'],
    nc15: ['üëÄ','üëÅÔ∏è','üëÖ','üëÑ','ü´¶','üë∂','üßí','üë¶','üëß','üßë','üë®','üë©'],
    nc16: ['üßî','üë®‚Äçü¶∞','üë©‚Äçü¶∞','üë®‚Äçü¶±','üë©‚Äçü¶±','üë®‚Äçü¶≥','üë©‚Äçü¶≥','üë®‚Äçü¶≤','üë©‚Äçü¶≤','üßë‚Äçü¶∞','üßë‚Äçü¶±','üßë‚Äçü¶≥'],
    nc17: ['üßë‚Äçü¶≤','üë±','üë±‚Äç‚ôÄÔ∏è','üßì','üë¥','üëµ','üôç','üôç‚Äç‚ôÇÔ∏è','üôç‚Äç‚ôÄÔ∏è','üôé','üôé‚Äç‚ôÇÔ∏è','üôé‚Äç‚ôÄÔ∏è'],
    nc18: ['üôÖ','üôÖ‚Äç‚ôÇÔ∏è','üôÖ‚Äç‚ôÄÔ∏è','üôÜ','üôÜ‚Äç‚ôÇÔ∏è','üôÜ‚Äç‚ôÄÔ∏è','üíÅ','üíÅ‚Äç‚ôÇÔ∏è','üíÅ‚Äç‚ôÄÔ∏è','üôã','üôã‚Äç‚ôÇÔ∏è','üôã‚Äç‚ôÄÔ∏è'],
    nc19: ['üßè','üßè‚Äç‚ôÇÔ∏è','üßè‚Äç‚ôÄÔ∏è','üôá','üôá‚Äç‚ôÇÔ∏è','üôá‚Äç‚ôÄÔ∏è','ü§¶','ü§¶‚Äç‚ôÇÔ∏è','ü§¶‚Äç‚ôÄÔ∏è','ü§∑','ü§∑‚Äç‚ôÇÔ∏è','ü§∑‚Äç‚ôÄÔ∏è'],
    nc20: ['üëÆ','üëÆ‚Äç‚ôÇÔ∏è','üëÆ‚Äç‚ôÄÔ∏è','üïµÔ∏è','üïµÔ∏è‚Äç‚ôÇÔ∏è','üïµÔ∏è‚Äç‚ôÄÔ∏è','üíÇ','üíÇ‚Äç‚ôÇÔ∏è','üíÇ‚Äç‚ôÄÔ∏è','ü•∑','üë∑','üë∑‚Äç‚ôÇÔ∏è'],
    
    // PEOPLE & PROFESSIONS (21-30)
    nc21: ['üë∑‚Äç‚ôÄÔ∏è','üë®‚Äç‚öïÔ∏è','üë©‚Äç‚öïÔ∏è','üë®‚Äçüéì','üë©‚Äçüéì','üë®‚Äçüè´','üë©‚Äçüè´','üë®‚Äç‚öñÔ∏è','üë©‚Äç‚öñÔ∏è','üë®‚Äçüåæ','üë©‚Äçüåæ','üë®‚Äçüç≥'],
    nc22: ['üë©‚Äçüç≥','üë®‚Äçüîß','üë©‚Äçüîß','üë®‚Äçüè≠','üë©‚Äçüè≠','üë®‚Äçüíº','üë©‚Äçüíº','üë®‚Äçüî¨','üë©‚Äçüî¨','üë®‚Äçüíª','üë©‚Äçüíª','üë®‚Äçüé§'],
    nc23: ['üë©‚Äçüé§','üë®‚Äçüé®','üë©‚Äçüé®','üë®‚Äç‚úàÔ∏è','üë©‚Äç‚úàÔ∏è','üë®‚ÄçüöÄ','üë©‚ÄçüöÄ','üë®‚Äçüöí','üë©‚Äçüöí','üëÆ','üïµÔ∏è','üíÇ'],
    nc24: ['üë∑','ü§¥','üë∏','üë≥','üë≥‚Äç‚ôÇÔ∏è','üë≥‚Äç‚ôÄÔ∏è','üßï','üë≤','üßî‚Äç‚ôÄÔ∏è','ü§µ','ü§µ‚Äç‚ôÇÔ∏è','ü§µ‚Äç‚ôÄÔ∏è'],
    nc25: ['üë∞','üë∞‚Äç‚ôÇÔ∏è','üë∞‚Äç‚ôÄÔ∏è','ü§∞','ü´É','ü´Ñ','ü§±','üëº','üéÖ','ü§∂','ü¶∏','ü¶∏‚Äç‚ôÇÔ∏è'],
    nc26: ['ü¶∏‚Äç‚ôÄÔ∏è','ü¶π','ü¶π‚Äç‚ôÇÔ∏è','ü¶π‚Äç‚ôÄÔ∏è','üßô','üßô‚Äç‚ôÇÔ∏è','üßô‚Äç‚ôÄÔ∏è','üßö','üßö‚Äç‚ôÇÔ∏è','üßö‚Äç‚ôÄÔ∏è','üßõ','üßõ‚Äç‚ôÇÔ∏è'],
    nc27: ['üßõ‚Äç‚ôÄÔ∏è','üßú','üßú‚Äç‚ôÇÔ∏è','üßú‚Äç‚ôÄÔ∏è','üßù','üßù‚Äç‚ôÇÔ∏è','üßù‚Äç‚ôÄÔ∏è','üßû','üßû‚Äç‚ôÇÔ∏è','üßû‚Äç‚ôÄÔ∏è','üßü','üßü‚Äç‚ôÇÔ∏è'],
    nc28: ['üßü‚Äç‚ôÄÔ∏è','üíÜ','üíÜ‚Äç‚ôÇÔ∏è','üíÜ‚Äç‚ôÄÔ∏è','üíá','üíá‚Äç‚ôÇÔ∏è','üíá‚Äç‚ôÄÔ∏è','üö∂','üö∂‚Äç‚ôÇÔ∏è','üö∂‚Äç‚ôÄÔ∏è','üèÉ','üèÉ‚Äç‚ôÇÔ∏è'],
    nc29: ['üèÉ‚Äç‚ôÄÔ∏è','üíÉ','üï∫','üï¥Ô∏è','üëØ','üëØ‚Äç‚ôÇÔ∏è','üëØ‚Äç‚ôÄÔ∏è','üßñ','üßñ‚Äç‚ôÇÔ∏è','üßñ‚Äç‚ôÄÔ∏è','üßó','üßó‚Äç‚ôÇÔ∏è'],
    nc30: ['üßó‚Äç‚ôÄÔ∏è','üèá','üèÇ','üèåÔ∏è','üèåÔ∏è‚Äç‚ôÇÔ∏è','üèåÔ∏è‚Äç‚ôÄÔ∏è','üèÑ','üèÑ‚Äç‚ôÇÔ∏è','üèÑ‚Äç‚ôÄÔ∏è','üö£','üö£‚Äç‚ôÇÔ∏è','üö£‚Äç‚ôÄÔ∏è'],
    
    // SPORTS & ACTIVITIES (31-40)
    nc31: ['üèä','üèä‚Äç‚ôÇÔ∏è','üèä‚Äç‚ôÄÔ∏è','‚õπÔ∏è','‚õπÔ∏è‚Äç‚ôÇÔ∏è','‚õπÔ∏è‚Äç‚ôÄÔ∏è','üèãÔ∏è','üèãÔ∏è‚Äç‚ôÇÔ∏è','üèãÔ∏è‚Äç‚ôÄÔ∏è','üö¥','üö¥‚Äç‚ôÇÔ∏è','üö¥‚Äç‚ôÄÔ∏è'],
    nc32: ['üöµ','üöµ‚Äç‚ôÇÔ∏è','üöµ‚Äç‚ôÄÔ∏è','ü§∏','ü§∏‚Äç‚ôÇÔ∏è','ü§∏‚Äç‚ôÄÔ∏è','ü§º','ü§º‚Äç‚ôÇÔ∏è','ü§º‚Äç‚ôÄÔ∏è','ü§Ω','ü§Ω‚Äç‚ôÇÔ∏è','ü§Ω‚Äç‚ôÄÔ∏è'],
    nc33: ['ü§æ','ü§æ‚Äç‚ôÇÔ∏è','ü§æ‚Äç‚ôÄÔ∏è','ü§∫','ü§π','ü§π‚Äç‚ôÇÔ∏è','ü§π‚Äç‚ôÄÔ∏è','üßò','üßò‚Äç‚ôÇÔ∏è','üßò‚Äç‚ôÄÔ∏è','üõÄ','üõå'],
    nc34: ['üßë‚Äçü§ù‚Äçüßë','üë≠','üë´','üë¨','üíè','üë©‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë®','üë®‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë®','üë©‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë©','üíë','üë©‚Äç‚ù§Ô∏è‚Äçüë®','üë®‚Äç‚ù§Ô∏è‚Äçüë®','üë©‚Äç‚ù§Ô∏è‚Äçüë©'],
    nc35: ['üë®‚Äçüë©‚Äçüë¶','üë®‚Äçüë©‚Äçüëß','üë®‚Äçüë©‚Äçüëß‚Äçüë¶','üë®‚Äçüë©‚Äçüë¶‚Äçüë¶','üë®‚Äçüë©‚Äçüëß‚Äçüëß','üë®‚Äçüë®‚Äçüë¶','üë®‚Äçüë®‚Äçüëß','üë®‚Äçüë®‚Äçüëß‚Äçüë¶','üë®‚Äçüë®‚Äçüë¶‚Äçüë¶','üë®‚Äçüë®‚Äçüëß‚Äçüëß','üë©‚Äçüë©‚Äçüë¶','üë©‚Äçüë©‚Äçüëß'],
    nc36: ['üë©‚Äçüë©‚Äçüëß‚Äçüë¶','üë©‚Äçüë©‚Äçüë¶‚Äçüë¶','üë©‚Äçüë©‚Äçüëß‚Äçüëß','üë®‚Äçüë¶','üë®‚Äçüë¶‚Äçüë¶','üë®‚Äçüëß','üë®‚Äçüëß‚Äçüë¶','üë®‚Äçüëß‚Äçüëß','üë©‚Äçüë¶','üë©‚Äçüë¶‚Äçüë¶','üë©‚Äçüëß','üë©‚Äçüëß‚Äçüë¶'],
    nc37: ['üë©‚Äçüëß‚Äçüëß','üó£Ô∏è','üë§','üë•','ü´Ç','üë£','üêµ','üêí','ü¶ç','ü¶ß','üê∂','üêï'],
    nc38: ['üê©','üê∫','ü¶ä','ü¶ù','üê±','üêà','ü¶Å','üêØ','üêÖ','üêÜ','üê¥','üêé'],
    nc39: ['ü¶Ñ','ü¶ì','ü¶å','üêÆ','üêÇ','üêÉ','üêÑ','üê∑','üêñ','üêó','üêΩ','üêè'],
    nc40: ['üêë','üêê','üê™','üê´','ü¶ô','ü¶í','üêò','ü¶è','ü¶õ','üê≠','üêÅ','üêÄ'],
    
    // ANIMALS (41-50)
    nc41: ['üêπ','üê∞','üêá','üêøÔ∏è','ü¶´','ü¶î','ü¶á','üêª','üê®','üêº','ü¶•','ü¶¶'],
    nc42: ['ü¶®','ü¶ò','ü¶°','üêæ','ü¶É','üêî','üêì','üê£','üê§','üê•','üê¶','üêß'],
    nc43: ['üïäÔ∏è','ü¶Ö','ü¶Ü','ü¶¢','ü¶â','ü¶§','ü™∂','ü¶©','ü¶ö','ü¶ú','üê∏','üêä'],
    nc44: ['üê¢','ü¶é','üêç','üê≤','üêâ','ü¶ï','ü¶ñ','üê≥','üêã','üê¨','ü¶≠','üêü'],
    nc45: ['üê†','üê°','ü¶à','üêô','üêö','ü™∏','üêå','ü¶ã','üêõ','üêú','üêù','ü™≤'],
    nc46: ['üêû','ü¶ó','üï∑Ô∏è','üï∏Ô∏è','ü¶Ç','ü¶ü','ü™≥','ü™∞','ü™±','ü¶†','üíê','üå∏'],
    nc47: ['üíÆ','ü™∑','üèµÔ∏è','üåπ','ü•Ä','üå∫','üåª','üåº','üå∑','üå±','ü™¥','üå≤'],
    nc48: ['üå≥','üå¥','üåµ','üåæ','üåø','‚òòÔ∏è','üçÄ','üçÅ','üçÇ','üçÉ','ü™π','ü™∫'],
    nc49: ['üçÑ','üçá','üçà','üçâ','üçä','üçã','üçå','üçç','ü•≠','üçé','üçè','üçê'],
    nc50: ['üçë','üçí','üçì','ü´ê','ü•ù','üçÖ','ü´í','ü••','ü•ë','üçÜ','ü•î','ü•ï'],
    
    // FOOD & DRINK (51-60)
    nc51: ['üåΩ','üå∂Ô∏è','ü´ë','ü•í','ü•¨','ü•¶','üßÑ','üßÖ','üçÑ','ü•ú','ü´ò','üå∞'],
    nc52: ['üçû','ü•ê','ü•ñ','ü´ì','ü•®','ü•Ø','ü•û','üßá','üßÄ','üçñ','üçó','ü•©'],
    nc53: ['ü•ì','üçî','üçü','üçï','üå≠','ü•™','üåÆ','üåØ','ü´î','ü•ô','üßÜ','ü•ö'],
    nc54: ['üç≥','ü•ò','üç≤','ü´ï','ü•£','ü•ó','üçø','üßà','üßÇ','ü•´','üçù','üçú'],
    nc55: ['üç†','üç¢','üç£','üç§','üç•','ü•Æ','üç°','ü•ü','ü•†','ü•°','ü¶™','üç¶'],
    nc56: ['üçß','üç®','üç©','üç™','üéÇ','üç∞','üßÅ','ü•ß','üç´','üç¨','üç≠','üçÆ'],
    nc57: ['üçØ','üçº','ü•õ','‚òï','ü´ñ','üçµ','üç∂','üçæ','üç∑','üç∏','üçπ','üç∫'],
    nc58: ['üçª','ü•Ç','ü•É','ü•§','üßã','üßÉ','üßâ','üßä','ü•¢','üçΩÔ∏è','üç¥','ü•Ñ'],
    nc59: ['üî™','üè∫','üåç','üåé','üåè','üåê','üó∫Ô∏è','üóæ','üß≠','üèîÔ∏è','‚õ∞Ô∏è','üåã'],
    nc60: ['üóª','üèïÔ∏è','üèñÔ∏è','üèúÔ∏è','üèùÔ∏è','üèûÔ∏è','üèüÔ∏è','üèõÔ∏è','üèóÔ∏è','üß±','ü™®','ü™µ'],
    
    // TRAVEL & PLACES (61-70)
    nc61: ['üõñ','üèòÔ∏è','üèöÔ∏è','üè†','üè°','üè¢','üè£','üè§','üè•','üè¶','üè®','üè©'],
    nc62: ['üè™','üè´','üè¨','üè≠','üèØ','üè∞','üíí','üóº','üóΩ','‚õ™','üïå','üõï'],
    nc63: ['üïç','‚õ©Ô∏è','üïã','‚õ≤','‚õ∫','üåÅ','üåÉ','üèôÔ∏è','üåÑ','üåÖ','üåÜ','üåá'],
    nc64: ['üåâ','‚ô®Ô∏è','üé†','üé°','üé¢','üíà','üé™','üöÇ','üöÉ','üöÑ','üöÖ','üöÜ'],
    nc65: ['üöá','üöà','üöâ','üöä','üöù','üöû','üöã','üöå','üöç','üöé','üöê','üöë'],
    nc66: ['üöí','üöì','üöî','üöï','üöñ','üöó','üöò','üöô','üõª','üöö','üöõ','üöú'],
    nc67: ['üèéÔ∏è','üèçÔ∏è','üõµ','üõ∫','üö≤','üõ¥','üöè','üõ£Ô∏è','üõ§Ô∏è','üõ¢Ô∏è','‚õΩ','üö®'],
    nc68: ['üö•','üö¶','üõë','üöß','‚öì','‚õµ','üõ∂','üö§','üõ≥Ô∏è','‚õ¥Ô∏è','üõ•Ô∏è','üö¢'],
    nc69: ['‚úàÔ∏è','üõ©Ô∏è','üõ´','üõ¨','ü™Ç','üí∫','üöÅ','üöü','üö†','üö°','üõ∞Ô∏è','üöÄ'],
    nc70: ['üõ∏','ü™ê','üå†','üåå','‚õ±Ô∏è','üß®','üéÜ','üéá','üéë','‚ú®','üéà','üéâ'],
    
    // OBJECTS & SYMBOLS (71-80)
    nc71: ['üéä','üéã','üéç','üéé','üéè','üéê','üéÄ','üéÅ','ü§ø','ü™Ä','ü™Å','üßø'],
    nc72: ['üé´','üéüÔ∏è','üéñÔ∏è','üèÜ','üèÖ','ü•á','ü•à','ü•â','‚öΩ','‚öæ','ü•é','üèÄ'],
    nc73: ['üèê','üèà','üèâ','üéæ','ü•è','üé≥','üèè','üèë','üèí','ü•ç','üèì','üè∏'],
    nc74: ['ü•ä','ü•ã','ü•Ö','‚õ≥','‚õ∏Ô∏è','üé£','ü§ø','üéΩ','üéø','üõ∑','ü•å','üéØ'],
    nc75: ['ü™Ä','ü™É','ü•è','üé±','üîÆ','üßø','ü™Ñ','üéÆ','üé∞','üé≤','üß©','üß∏'],
    nc76: ['ü™Ö','ü™Ü','‚ô†Ô∏è','‚ô•Ô∏è','‚ô¶Ô∏è','‚ô£Ô∏è','‚ôüÔ∏è','üÉè','üÄÑ','üé¥','üé≠','üñºÔ∏è'],
    nc77: ['üé®','üßµ','ü™°','üß∂','ü™¢','üëì','üï∂Ô∏è','ü•Ω','ü•º','ü¶∫','üëî','üëï'],
    nc78: ['üëñ','üß£','üß§','üß•','üß¶','üëó','üëò','ü•ª','ü©±','ü©≤','ü©≥','üëô'],
    nc79: ['üëö','üëõ','üëú','üëù','üéí','ü©¥','üëû','üëü','ü•æ','ü•ø','üë†','üë°'],
    nc80: ['ü©∞','üë¢','üëë','üëí','üé©','üéì','üß¢','ü™ñ','‚õëÔ∏è','üíÑ','üíç','üíº'],
    
    // PHONE & TECH (81-90)
    nc81: ['üì±','üì≤','‚òéÔ∏è','üìû','üìü','üì†','üîã','üîå','üíª','üñ•Ô∏è','üñ®Ô∏è','‚å®Ô∏è'],
    nc82: ['üñ±Ô∏è','üñ≤Ô∏è','üíΩ','üíæ','üíø','üìÄ','üßÆ','üé•','üìΩÔ∏è','üé¨','üì∫','üì∑'],
    nc83: ['üì∏','üìπ','üìº','üîç','üîé','üïØÔ∏è','üí°','üî¶','üèÆ','ü™î','üìî','üìï'],
    nc84: ['üìñ','üóÇÔ∏è','üìÇ','üìÖ','üìÜ','üóíÔ∏è','üìä','üìà','üìâ','üóÉÔ∏è','üóÑÔ∏è','üóëÔ∏è'],
    nc85: ['üîí','üîì','üîè','üîê','üîë','üóùÔ∏è','üî®','ü™ì','‚õèÔ∏è','‚öíÔ∏è','üõ†Ô∏è','üó°Ô∏è'],
    nc86: ['‚öîÔ∏è','üî´','üèπ','üõ°Ô∏è','üîß','üî©','‚öôÔ∏è','üóúÔ∏è','‚öñÔ∏è','ü¶Ø','üîó','‚õìÔ∏è'],
    nc87: ['üß∞','üß≤','‚öóÔ∏è','üß™','üß´','üß¨','üî¨','üî≠','üì°','üíâ','ü©∏','üíä'],
    nc88: ['ü©π','ü©∫','üö™','üõèÔ∏è','üõãÔ∏è','ü™ë','üöΩ','üöø','üõÅ','üß¥','üß∑','üßπ'],
    nc89: ['üß∫','üßª','ü™£','üßº','ü™•','üßΩ','üßØ','üõí','üö¨','‚ö∞Ô∏è','ü™¶','‚ö±Ô∏è'],
    nc90: ['üèß','üöÆ','üö∞','‚ôø','üöπ','üö∫','üöª','üöº','üöæ','üõÇ','üõÉ','üõÑ'],
    
    // SYMBOLS & SIGNS (91-100)
    nc91: ['üõÖ','‚ö†Ô∏è','üö∏','‚õî','üö´','üö≥','üö≠','üöØ','üö±','üö∑','üìµ','üîû'],
    nc92: ['‚ò¢Ô∏è','‚ò£Ô∏è','‚¨ÜÔ∏è','‚ÜóÔ∏è','‚û°Ô∏è','‚ÜòÔ∏è','‚¨áÔ∏è','‚ÜôÔ∏è','‚¨ÖÔ∏è','‚ÜñÔ∏è','‚ÜïÔ∏è','‚ÜîÔ∏è'],
    nc93: ['‚Ü©Ô∏è','‚Ü™Ô∏è','‚§¥Ô∏è','‚§µÔ∏è','üîÉ','üîÑ','üîô','üîö','üîõ','üîú','üîù','üõê'],
    nc94: ['‚öõÔ∏è','üïâÔ∏è','‚ú°Ô∏è','‚ò∏Ô∏è','‚ò™Ô∏è','‚úùÔ∏è','‚ò¶Ô∏è','‚òÆÔ∏è','üïé','üîØ','‚ôà','‚ôâ'],
    nc95: ['‚ôä','‚ôã','‚ôå','‚ôç','‚ôé','‚ôè','‚ôê','‚ôë','‚ôí','‚ôì','‚õé','üîÄ'],
    nc96: ['üîÅ','üîÇ','‚ñ∂Ô∏è','‚è©','‚è≠Ô∏è','‚èØÔ∏è','‚óÄÔ∏è','‚è™','‚èÆÔ∏è','üîº','‚è´','üîΩ'],
    nc97: ['‚è¨','‚è∏Ô∏è','‚èπÔ∏è','‚è∫Ô∏è','‚èèÔ∏è','üé¶','üîÖ','üîÜ','üì∂','üì≥','üì¥','‚ôÄÔ∏è'],
    nc98: ['‚ôÇÔ∏è','‚ößÔ∏è','‚úñÔ∏è','‚ûï','‚ûñ','‚ûó','‚ôæÔ∏è','‚ÄºÔ∏è','‚ÅâÔ∏è','‚ùì','‚ùî','‚ùï'],
    nc99: ['‚ùó','„Ä∞Ô∏è','üí±','üí≤','‚öïÔ∏è','‚ôªÔ∏è','‚öúÔ∏è','üî±','üìõ','üî∞','‚≠ï','üü†'],
    nc100: ['üü°','üü¢','üîµ','üü£','üü§','‚ö´','‚ö™','üü•','üüß','üü®','üü©','üü¶']
};

// ========== FONT STYLES FOR TEXT ==========
const fontStyles = {
    // DOUBLE STRIKE/BOLD FONTS
    double: {
        name: "Double Strike",
        chars: {
            'A': 'ùî∏', 'B': 'ùîπ', 'C': '‚ÑÇ', 'D': 'ùîª', 'E': 'ùîº', 'F': 'ùîΩ', 'G': 'ùîæ',
            'H': '‚Ñç', 'I': 'ùïÄ', 'J': 'ùïÅ', 'K': 'ùïÇ', 'L': 'ùïÉ', 'M': 'ùïÑ', 'N': '‚Ñï',
            'O': 'ùïÜ', 'P': '‚Ñô', 'Q': '‚Ñö', 'R': '‚Ñù', 'S': 'ùïä', 'T': 'ùïã', 'U': 'ùïå',
            'V': 'ùïç', 'W': 'ùïé', 'X': 'ùïè', 'Y': 'ùïê', 'Z': '‚Ñ§',
            'a': 'ùïí', 'b': 'ùïì', 'c': 'ùïî', 'd': 'ùïï', 'e': 'ùïñ', 'f': 'ùïó', 'g': 'ùïò',
            'h': 'ùïô', 'i': 'ùïö', 'j': 'ùïõ', 'k': 'ùïú', 'l': 'ùïù', 'm': 'ùïû', 'n': 'ùïü',
            'o': 'ùï†', 'p': 'ùï°', 'q': 'ùï¢', 'r': 'ùï£', 's': 'ùï§', 't': 'ùï•', 'u': 'ùï¶',
            'v': 'ùïß', 'w': 'ùï®', 'x': 'ùï©', 'y': 'ùï™', 'z': 'ùï´',
            '0': 'ùüò', '1': 'ùüô', '2': 'ùüö', '3': 'ùüõ', '4': 'ùüú', '5': 'ùüù', '6': 'ùüû',
            '7': 'ùüü', '8': 'ùü†', '9': 'ùü°'
        }
    },
    
    // MONOSPACE/BLOCK FONTS
    mono: {
        name: "Monospace",
        chars: {
            'A': 'ùô∞', 'B': 'ùô±', 'C': 'ùô≤', 'D': 'ùô≥', 'E': 'ùô¥', 'F': 'ùôµ', 'G': 'ùô∂',
            'H': 'ùô∑', 'I': 'ùô∏', 'J': 'ùôπ', 'K': 'ùô∫', 'L': 'ùôª', 'M': 'ùôº', 'N': 'ùôΩ',
            'O': 'ùôæ', 'P': 'ùôø', 'Q': 'ùöÄ', 'R': 'ùöÅ', 'S': 'ùöÇ', 'T': 'ùöÉ', 'U': 'ùöÑ',
            'V': 'ùöÖ', 'W': 'ùöÜ', 'X': 'ùöá', 'Y': 'ùöà', 'Z': 'ùöâ',
            'a': 'ùöä', 'b': 'ùöã', 'c': 'ùöå', 'd': 'ùöç', 'e': 'ùöé', 'f': 'ùöè', 'g': 'ùöê',
            'h': 'ùöë', 'i': 'ùöí', 'j': 'ùöì', 'k': 'ùöî', 'l': 'ùöï', 'm': 'ùöñ', 'n': 'ùöó',
            'o': 'ùöò', 'p': 'ùöô', 'q': 'ùöö', 'r': 'ùöõ', 's': 'ùöú', 't': 'ùöù', 'u': 'ùöû',
            'v': 'ùöü', 'w': 'ùö†', 'x': 'ùö°', 'y': 'ùö¢', 'z': 'ùö£',
            '0': 'ùü∂', '1': 'ùü∑', '2': 'ùü∏', '3': 'ùüπ', '4': 'ùü∫', '5': 'ùüª', '6': 'ùüº',
            '7': 'ùüΩ', '8': 'ùüæ', '9': 'ùüø'
        }
    },
    
    // SCRIPT/CURSIVE FONTS
    script: {
        name: "Script",
        chars: {
            'A': 'ùíú', 'B': 'ùêµ', 'C': 'ùíû', 'D': 'ùíü', 'E': 'ùê∏', 'F': 'ùêπ', 'G': 'ùí¢',
            'H': 'ùêª', 'I': 'ùêº', 'J': 'ùí•', 'K': 'ùí¶', 'L': 'ùêø', 'M': 'ùëÄ', 'N': 'ùí©',
            'O': 'ùí™', 'P': 'ùí´', 'Q': 'ùí¨', 'R': 'ùëÖ', 'S': 'ùíÆ', 'T': 'ùíØ', 'U': 'ùí∞',
            'V': 'ùí±', 'W': 'ùí≤', 'X': 'ùí≥', 'Y': 'ùí¥', 'Z': 'ùíµ',
            'a': 'ùí∂', 'b': 'ùí∑', 'c': 'ùí∏', 'd': 'ùíπ', 'e': 'ùëí', 'f': 'ùíª', 'g': '‚Ñä',
            'h': 'ùíΩ', 'i': 'ùíæ', 'j': 'ùíø', 'k': 'ùìÄ', 'l': 'ùìÅ', 'm': 'ùìÇ', 'n': 'ùìÉ',
            'o': 'ùëú', 'p': 'ùìÖ', 'q': 'ùìÜ', 'r': 'ùìá', 's': 'ùìà', 't': 'ùìâ', 'u': 'ùìä',
            'v': 'ùìã', 'w': 'ùìå', 'x': 'ùìç', 'y': 'ùìé', 'z': 'ùìè'
        }
    },
    
    // BOLD SCRIPT FONTS
    boldscript: {
        name: "Bold Script",
        chars: {
            'A': 'ùìê', 'B': 'ùìë', 'C': 'ùìí', 'D': 'ùìì', 'E': 'ùìî', 'F': 'ùìï', 'G': 'ùìñ',
            'H': 'ùìó', 'I': 'ùìò', 'J': 'ùìô', 'K': 'ùìö', 'L': 'ùìõ', 'M': 'ùìú', 'N': 'ùìù',
            'O': 'ùìû', 'P': 'ùìü', 'Q': 'ùì†', 'R': 'ùì°', 'S': 'ùì¢', 'T': 'ùì£', 'U': 'ùì§',
            'V': 'ùì•', 'W': 'ùì¶', 'X': 'ùìß', 'Y': 'ùì®', 'Z': 'ùì©',
            'a': 'ùì™', 'b': 'ùì´', 'c': 'ùì¨', 'd': 'ùì≠', 'e': 'ùìÆ', 'f': 'ùìØ', 'g': 'ùì∞',
            'h': 'ùì±', 'i': 'ùì≤', 'j': 'ùì≥', 'k': 'ùì¥', 'l': 'ùìµ', 'm': 'ùì∂', 'n': 'ùì∑',
            'o': 'ùì∏', 'p': 'ùìπ', 'q': 'ùì∫', 'r': 'ùìª', 's': 'ùìº', 't': 'ùìΩ', 'u': 'ùìæ',
            'v': 'ùìø', 'w': 'ùîÄ', 'x': 'ùîÅ', 'y': 'ùîÇ', 'z': 'ùîÉ'
        }
    },
    
    // GOTHIC/BLACKLETTER FONTS
    gothic: {
        name: "Gothic",
        chars: {
            'A': 'ùîÑ', 'B': 'ùîÖ', 'C': '‚Ñ≠', 'D': 'ùîá', 'E': 'ùîà', 'F': 'ùîâ', 'G': 'ùîä',
            'H': '‚Ñå', 'I': '‚Ñë', 'J': 'ùîç', 'K': 'ùîé', 'L': 'ùîè', 'M': 'ùîê', 'N': 'ùîë',
            'O': 'ùîí', 'P': 'ùîì', 'Q': 'ùîî', 'R': '‚Ñú', 'S': 'ùîñ', 'T': 'ùîó', 'U': 'ùîò',
            'V': 'ùîô', 'W': 'ùîö', 'X': 'ùîõ', 'Y': 'ùîú', 'Z': '‚Ñ®'
        }
    },
    
    // BOLD GOTHIC FONTS
    boldgothic: {
        name: "Bold Gothic",
        chars: {
            'A': 'ùï¨', 'B': 'ùï≠', 'C': 'ùïÆ', 'D': 'ùïØ', 'E': 'ùï∞', 'F': 'ùï±', 'G': 'ùï≤',
            'H': 'ùï≥', 'I': 'ùï¥', 'J': 'ùïµ', 'K': 'ùï∂', 'L': 'ùï∑', 'M': 'ùï∏', 'N': 'ùïπ',
            'O': 'ùï∫', 'P': 'ùïª', 'Q': 'ùïº', 'R': 'ùïΩ', 'S': 'ùïæ', 'T': 'ùïø', 'U': 'ùñÄ',
            'V': 'ùñÅ', 'W': 'ùñÇ', 'X': 'ùñÉ', 'Y': 'ùñÑ', 'Z': 'ùñÖ',
            'a': 'ùñÜ', 'b': 'ùñá', 'c': 'ùñà', 'd': 'ùñâ', 'e': 'ùñä', 'f': 'ùñã', 'g': 'ùñå',
            'h': 'ùñç', 'i': 'ùñé', 'j': 'ùñè', 'k': 'ùñê', 'l': 'ùñë', 'm': 'ùñí', 'n': 'ùñì',
            'o': 'ùñî', 'p': 'ùñï', 'q': 'ùññ', 'r': 'ùñó', 's': 'ùñò', 't': 'ùñô', 'u': 'ùñö',
            'v': 'ùñõ', 'w': 'ùñú', 'x': 'ùñù', 'y': 'ùñû', 'z': 'ùñü'
        }
    },
    
    // SQUARE/FULLWIDTH FONTS
    square: {
        name: "Square",
        chars: {
            'A': 'Ôº°', 'B': 'Ôº¢', 'C': 'Ôº£', 'D': 'Ôº§', 'E': 'Ôº•', 'F': 'Ôº¶', 'G': 'Ôºß',
            'H': 'Ôº®', 'I': 'Ôº©', 'J': 'Ôº™', 'K': 'Ôº´', 'L': 'Ôº¨', 'M': 'Ôº≠', 'N': 'ÔºÆ',
            'O': 'ÔºØ', 'P': 'Ôº∞', 'Q': 'Ôº±', 'R': 'Ôº≤', 'S': 'Ôº≥', 'T': 'Ôº¥', 'U': 'Ôºµ',
            'V': 'Ôº∂', 'W': 'Ôº∑', 'X': 'Ôº∏', 'Y': 'Ôºπ', 'Z': 'Ôº∫',
            'a': 'ÔΩÅ', 'b': 'ÔΩÇ', 'c': 'ÔΩÉ', 'd': 'ÔΩÑ', 'e': 'ÔΩÖ', 'f': 'ÔΩÜ', 'g': 'ÔΩá',
            'h': 'ÔΩà', 'i': 'ÔΩâ', 'j': 'ÔΩä', 'k': 'ÔΩã', 'l': 'ÔΩå', 'm': 'ÔΩç', 'n': 'ÔΩé',
            'o': 'ÔΩè', 'p': 'ÔΩê', 'q': 'ÔΩë', 'r': 'ÔΩí', 's': 'ÔΩì', 't': 'ÔΩî', 'u': 'ÔΩï',
            'v': 'ÔΩñ', 'w': 'ÔΩó', 'x': 'ÔΩò', 'y': 'ÔΩô', 'z': 'ÔΩö',
            '0': 'Ôºê', '1': 'Ôºë', '2': 'Ôºí', '3': 'Ôºì', '4': 'Ôºî', '5': 'Ôºï', '6': 'Ôºñ',
            '7': 'Ôºó', '8': 'Ôºò', '9': 'Ôºô'
        }
    },
    
    // CIRCLED FONTS
    circled: {
        name: "Circled",
        chars: {
            'A': '‚í∂', 'B': '‚í∑', 'C': '‚í∏', 'D': '‚íπ', 'E': '‚í∫', 'F': '‚íª', 'G': '‚íº',
            'H': '‚íΩ', 'I': '‚íæ', 'J': '‚íø', 'K': '‚ìÄ', 'L': '‚ìÅ', 'M': '‚ìÇ', 'N': '‚ìÉ',
            'O': '‚ìÑ', 'P': '‚ìÖ', 'Q': '‚ìÜ', 'R': '‚ìá', 'S': '‚ìà', 'T': '‚ìâ', 'U': '‚ìä',
            'V': '‚ìã', 'W': '‚ìå', 'X': '‚ìç', 'Y': '‚ìé', 'Z': '‚ìè',
            'a': '‚ìê', 'b': '‚ìë', 'c': '‚ìí', 'd': '‚ìì', 'e': '‚ìî', 'f': '‚ìï', 'g': '‚ìñ',
            'h': '‚ìó', 'i': '‚ìò', 'j': '‚ìô', 'k': '‚ìö', 'l': '‚ìõ', 'm': '‚ìú', 'n': '‚ìù',
            'o': '‚ìû', 'p': '‚ìü', 'q': '‚ì†', 'r': '‚ì°', 's': '‚ì¢', 't': '‚ì£', 'u': '‚ì§',
            'v': '‚ì•', 'w': '‚ì¶', 'x': '‚ìß', 'y': '‚ì®', 'z': '‚ì©',
            '0': '‚ì™', '1': '‚ë†', '2': '‚ë°', '3': '‚ë¢', '4': '‚ë£', '5': '‚ë§', '6': '‚ë•',
            '7': '‚ë¶', '8': '‚ëß', '9': '‚ë®'
        }
    }
};

// Function to convert text to a specific font style
function convertToFont(text, fontName) {
    const font = fontStyles[fontName];
    if (!font) return text;
    
    return text.split('').map(char => {
        const upperChar = char.toUpperCase();
        const lowerChar = char.toLowerCase();
        
        if (font.chars[upperChar]) {
            return char === upperChar ? font.chars[upperChar] : font.chars[lowerChar] || font.chars[upperChar] || char;
        }
        return font.chars[char] || char;
    }).join('');
}

// ========== TRIPLE ATTACK DEFINITIONS ==========
const tripleNcCombos = {
    // Format: tripleName: [nc1, nc2, nc3] - Each runs as separate attack
    triple1: ['nc1', 'nc2', 'nc3'],
    triple2: ['nc4', 'nc5', 'nc6'],
    triple3: ['nc7', 'nc8', 'nc9'],
    triple4: ['nc10', 'nc11', 'nc12'],
    triple5: ['nc13', 'nc14', 'nc15'],
    triple6: ['nc16', 'nc17', 'nc18'],
    triple7: ['nc19', 'nc20', 'nc21'],
    triple8: ['nc22', 'nc23', 'nc24'],
    triple9: ['nc25', 'nc26', 'nc27'],
    triple10: ['nc28', 'nc29', 'nc30'],
    
    // PHONE KEYBOARD TRIPLE ATTACKS
    triple11: ['nc81', 'nc82', 'nc83'],
    triple12: ['nc84', 'nc85', 'nc86'],
    triple13: ['nc87', 'nc88', 'nc89'],
    triple14: ['nc90', 'nc91', 'nc92'],
    triple15: ['nc93', 'nc94', 'nc95'],
    
    // FACE ATTACKS
    triple16: ['nc1', 'nc4', 'nc7'],
    triple17: ['nc2', 'nc5', 'nc8'],
    triple18: ['nc3', 'nc6', 'nc9'],
    
    // HAND ATTACKS
    triple19: ['nc11', 'nc12', 'nc13'],
    
    // FOOD ATTACKS
    triple20: ['nc50', 'nc51', 'nc52'],
    triple21: ['nc53', 'nc54', 'nc55'],
    triple22: ['nc56', 'nc57', 'nc58'],
    
    // TRAVEL ATTACKS
    triple23: ['nc64', 'nc65', 'nc66'],
    triple24: ['nc67', 'nc68', 'nc69'],
    
    // SPORTS ATTACKS
    triple25: ['nc72', 'nc73', 'nc74'],
    
    // CLOTHING ATTACKS
    triple26: ['nc77', 'nc78', 'nc79'],
    
    // SYMBOL ATTACKS
    triple27: ['nc93', 'nc97', 'nc99'],
    triple28: ['nc94', 'nc95', 'nc96'],
    triple29: ['nc98', 'nc99', 'nc100'],
    
    // MIXED ATTACKS
    triple30: ['nc31', 'nc41', 'nc71'],
    triple31: ['nc20', 'nc40', 'nc60'],
    triple32: ['nc35', 'nc45', 'nc55'],
    triple33: ['nc25', 'nc35', 'nc45'],
    triple34: ['nc15', 'nc25', 'nc35'],
    triple35: ['nc5', 'nc15', 'nc25']
};

// ========== UPDATED NEXA MENU ==========
const NEXAMenu = `
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë         ‚ö°‚ö°‚ö° NEXA BOT v3.0 ‚ö°‚ö°‚ö°         ‚ïë
‚ïë       ‚ö° TRIPLE NC ATTACK SYSTEM ‚ö°          ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  üëë ADMIN COMMANDS                           ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  +admin      ‚Üí Become admin (DM)             ‚ïë
‚ïë  -admin      ‚Üí Remove yourself               ‚ïë
‚ïë  +sub        ‚Üí Make sub-admin (reply)        ‚ïë
‚ïë  -sub        ‚Üí Remove sub-admin              ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  ü§ñ BOT MANAGEMENT                           ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  +add [num]  ‚Üí Add new bot                   ‚ïë
‚ïë  +bots       ‚Üí List all bots                 ‚ïë
‚ïë  +ping       ‚Üí Check bot latency             ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  ‚ö° TEXT + EMOJI ATTACKS (NEW!) ‚ö°           ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  +tne [font] [nc#] [text] [delay]           ‚ïë
‚ïë  Fonts: double, mono, script, boldscript    ‚ïë
‚ïë          gothic, boldgothic, square, circled‚ïë
‚ïë  Example: +tne double nc1 RAID 1000         ‚ïë
‚ïë  Example: +tne script nc50 HELLO 1500       ‚ïë
‚ïë  +fonts       ‚Üí Show available fonts        ‚ïë
‚ïë  -tne         ‚Üí Stop text+emoji attacks     ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  ‚ö° TRIPLE NC ATTACKS (35 Types) ‚ö°          ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  +triple1 [text]  ‚Üí Starts: nc1 + nc2 + nc3  ‚ïë
‚ïë  +triple2 [text]  ‚Üí Starts: nc4 + nc5 + nc6  ‚ïë
‚ïë  +triple3 [text]  ‚Üí Starts: nc7 + nc8 + nc9  ‚ïë
‚ïë  +triple4 [text]  ‚Üí Starts: nc10+nc11+nc12   ‚ïë
‚ïë  +triple5 [text]  ‚Üí Starts: nc13+nc14+nc15   ‚ïë
‚ïë  ... up to +triple35                        ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  DELAY CONTROLS                             ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  +delaytriple[1-35] [ms] ‚Üí Set triple delay ‚ïë
‚ïë  +delaync[1-100] [ms]    ‚Üí Set NC delay     ‚ïë
‚ïë  +delays                ‚Üí Show all delays   ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  ‚ö° INDIVIDUAL NC ATTACKS (100 Types) ‚ö°    ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  +nc1 to +nc100 [text] ‚Üí Single NC attacks  ‚ïë
‚ïë  -nc                   ‚Üí Stop NC attacks    ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  üí¨ MESSAGE ATTACKS                        ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  +s [text] [delay]  ‚Üí Slide attack         ‚ïë
‚ïë  -s                 ‚Üí Stop slides          ‚ïë
‚ïë  +txt [text] [delay]‚Üí Text spam            ‚ïë
‚ïë  -txt               ‚Üí Stop text            ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  üé§ TTS VOICE ATTACKS                      ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  +tts [text]        ‚Üí Send voice           ‚ïë
‚ïë  +ttsatk [text] [delay] ‚Üí Voice spam       ‚ïë
‚ïë  -ttsatk            ‚Üí Stop voice           ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  üì∏ PICTURE ATTACKS                        ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  +pic [delay]       ‚Üí Pic spam             ‚ïë
‚ïë                      (reply to pic)         ‚ïë
‚ïë  -pic               ‚Üí Stop pic             ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  üõë STOP ALL                               ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  -all        ‚Üí Stop all attacks            ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  üìã INFO                                   ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  +menu       ‚Üí Show this menu              ‚ïë
‚ïë  +status     ‚Üí Active attacks              ‚ïë
‚ïë  +delays     ‚Üí Show current delays         ‚ïë
‚ïë  +triples    ‚Üí List triple combos          ‚ïë
‚ïë  +fonts      ‚Üí Show all font styles        ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë       ‚ö° ULTIMATE POWER ‚ö°                   ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
`;

const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
const question = (text) => new Promise((resolve) => rl.question(text, resolve));

async function generateTTS(text, lang = 'en') {
    return new Promise((resolve, reject) => {
        const tts = gtts(lang);
        const chunks = [];
        
        tts.stream(text).on('data', (chunk) => {
            chunks.push(chunk);
        }).on('end', () => {
            resolve(Buffer.concat(chunks));
        }).on('error', (err) => {
            reject(err);
        });
    });
}

// ========== CLASS DEFINITIONS ==========
class CommandBus {
    constructor() {
        this.botSessions = new Map();
        this.processedMessages = new Map();
        this.messageCleanupInterval = 60000;
        
        setInterval(() => {
            const now = Date.now();
            this.processedMessages.forEach((timestamp, msgId) => {
                if (now - timestamp > this.messageCleanupInterval) {
                    this.processedMessages.delete(msgId);
                }
            });
        }, this.messageCleanupInterval);
    }

    registerBot(botId, session) {
        this.botSessions.set(botId, session);
    }

    unregisterBot(botId) {
        this.botSessions.delete(botId);
    }

    shouldProcessMessage(msgId) {
        if (this.processedMessages.has(msgId)) {
            return false;
        }
        this.processedMessages.set(msgId, Date.now());
        return true;
    }

    async broadcastCommand(commandType, data, originBotId, sendConfirmation = true) {
        const bots = Array.from(this.botSessions.values()).filter(b => b.connected);
        
        for (const bot of bots) {
            try {
                const isOrigin = bot.botId === originBotId;
                await bot.executeCommand(commandType, data, isOrigin && sendConfirmation);
            } catch (err) {
                console.error(`[${bot.botId}] Command execution error:`, err.message);
            }
        }
    }

    getAllBots() {
        return Array.from(this.botSessions.values());
    }

    getConnectedBots() {
        return Array.from(this.botSessions.values()).filter(b => b.connected);
    }

    getLeaderBot() {
        const connected = this.getConnectedBots();
        return connected.length > 0 ? connected[0] : null;
    }
}

class BotSession {
    constructor(botId, phoneNumber, botManager, requestingJid = null) {
        this.botId = botId;
        this.phoneNumber = phoneNumber;
        this.botManager = botManager;
        this.requestingJid = requestingJid;
        this.sock = null;
        this.connected = false;
        this.botNumber = null;
        this.authPath = `./auth/${botId}`;
        this.pairingCodeRequested = false;
        
        this.activeNameChanges = new Map();
        this.activeTripleNc = new Map();
        this.activeSlides = new Map();
        this.activeTxtSenders = new Map();
        this.activeTTSSenders = new Map();
        this.activePicSenders = new Map();
        this.activeTextEmojiAttacks = new Map(); // NEW: For text+emoji attacks
    }

    async connect() {
        try {
            if (!fs.existsSync(this.authPath)) {
                fs.mkdirSync(this.authPath, { recursive: true });
            }

            const { state, saveCreds } = await useMultiFileAuthState(this.authPath);
            const { version } = await fetchLatestBaileysVersion();
            
            const needsPairing = !state.creds.registered;

            this.sock = makeWASocket({
                auth: state,
                logger: pino({ level: 'silent' }),
                browser: Browsers.macOS('Chrome'),
                version,
                printQRInTerminal: false,
                connectTimeoutMs: 60000,
                defaultQueryTimeoutMs: 0,
                keepAliveIntervalMs: 30000,
                emitOwnEvents: true,
                fireInitQueries: true,
                generateHighQualityLinkPreview: false,
                syncFullHistory: false,
                markOnlineOnConnect: false
            });

            this.sock.ev.on('connection.update', async (update) => {
                const { connection, lastDisconnect } = update;

                if (needsPairing && this.phoneNumber && !this.pairingCodeRequested && !state.creds.registered) {
                    this.pairingCodeRequested = true;
                    await delay(2000);
                    try {
                        const code = await this.sock.requestPairingCode(this.phoneNumber);
                        console.log(`[${this.botId}] Pairing code: ${code}`);
                        
                        if (this.requestingJid) {
                            const connectedBots = this.botManager.commandBus.getConnectedBots();
                            if (connectedBots.length > 0) {
                                const firstBot = connectedBots[0];
                                await firstBot.sock.sendMessage(this.requestingJid, {
                                    text: `ü§ñ *${this.botId} PAIRING CODE* ü§ñ\n\n` +
                                          `‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n` +
                                          `‚ïë      YOUR PAIRING CODE IS:       ‚ïë\n` +
                                          `‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n` +
                                          `‚ïë          ${code}              ‚ïë\n` +
                                          `‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n` +
                                          `‚ïë  Go to WhatsApp > Linked Devices ‚ïë\n` +
                                          `‚ïë  > Link a Device > Link with     ‚ïë\n` +
                                          `‚ïë  phone number instead            ‚ïë\n` +
                                          `‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n` +
                                          `üì± Number: ${this.phoneNumber}`
                                });
                            }
                        } else {
                            console.log(`\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó`);
                            console.log(`‚ïë   ${this.botId} PAIRING CODE        ‚ïë`);
                            console.log(`‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£`);
                            console.log(`‚ïë          ${code}              ‚ïë`);
                            console.log(`‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£`);
                            console.log(`‚ïë  Go to WhatsApp > Linked Devices ‚ïë`);
                            console.log(`‚ïë  > Link a Device > Link with     ‚ïë`);
                            console.log(`‚ïë  phone number instead            ‚ïë`);
                            console.log(`‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n`);
                        }
                    } catch (err) {
                        console.error(`[${this.botId}] Error getting pairing code:`, err.message);
                        this.pairingCodeRequested = false;
                    }
                }

                if (connection === 'close') {
                    const statusCode = (lastDisconnect?.error instanceof Boom)
                        ? lastDisconnect.error.output.statusCode
                        : 500;

                    const shouldReconnect = statusCode !== DisconnectReason.loggedOut;
                    
                    console.log(`[${this.botId}] Connection closed. Status: ${statusCode}`);
                    this.connected = false;

                    if (shouldReconnect) {
                        console.log(`[${this.botId}] Reconnecting in 5 seconds...`);
                        await delay(5000);
                        this.connect();
                    } else {
                        console.log(`[${this.botId}] Logged out.`);
                        this.botManager.removeBot(this.botId);
                    }
                } else if (connection === 'open') {
                    console.log(`[${this.botId}] ‚úÖ CONNECTED!`);
                    this.connected = true;
                    this.botNumber = this.sock.user.id.split(':')[0] + '@s.whatsapp.net';
                    console.log(`[${this.botId}] Number:`, this.botNumber);
                }
            });

            this.sock.ev.on('creds.update', saveCreds);
            this.sock.ev.on('messages.upsert', async (m) => this.handleMessage(m));

        } catch (err) {
            console.error(`[${this.botId}] Connection error:`, err.message);
        }
    }

    async handleMessage({ messages, type }) {
        try {
            if (type !== 'notify') return;
            
            const msg = messages[0];
            if (!msg.message) return;
            if (msg.key.fromMe) return;
            
            const messageType = Object.keys(msg.message)[0];
            if (messageType === 'protocolMessage' || messageType === 'senderKeyDistributionMessage') return;

            const from = msg.key.remoteJid;
            const isGroup = from.endsWith('@g.us');
            const sender = isGroup ? msg.key.participant : from;
            
            const msgId = msg.key.id;
            const isLeader = this.botManager.commandBus.getLeaderBot()?.botId === this.botId;
            
            if (!isLeader && !this.botManager.commandBus.shouldProcessMessage(msgId)) {
                return;
            }
            
            if (isLeader) {
                if (!this.botManager.commandBus.shouldProcessMessage(msgId)) {
                    return;
                }
            }
            
            // Update slide messages
            this.activeSlides.forEach((task, taskId) => {
                if (task.active && task.groupJid === from && task.targetJid === sender) {
                    task.latestMsg = msg;
                    task.hasNewMsg = true;
                }
            });
            
            let text = msg.message.conversation || 
                      msg.message.extendedTextMessage?.text || 
                      msg.message.imageMessage?.caption || '';

            const originalText = text;
            text = text.trim().toLowerCase();

            console.log(`[${this.botId}] MSG from ${sender}: ${text}`);

            const isDM = !isGroup;
            const senderIsAdmin = isAdmin(sender);
            const senderIsSubAdmin = isGroup ? isSubAdmin(sender, from) : false;
            const senderHasPermission = senderIsAdmin || senderIsSubAdmin;

            // ADMIN COMMANDS
            if (isDM && text === '+admin') {
                if (roles.admins.length === 0) {
                    addAdmin(sender);
                    await this.sendMessage(from, `‚ö° *NEXA ${this.botId}* ‚ö°\n\n‚úÖ You are now the ADMIN!\n\nSend *+menu* to see commands`);
                    console.log(`[${this.botId}] New admin:`, sender);
                } else if (senderIsAdmin) {
                    await this.sendMessage(from, `‚ö†Ô∏è You are already the admin! - ${this.botId}`);
                } else {
                    await this.sendMessage(from, `‚ùå Admin already exists! Only one admin allowed. - ${this.botId}`);
                }
                return;
            }

            if (isDM && text === '-admin') {
                if (senderIsAdmin) {
                    removeAdmin(sender);
                    await this.sendMessage(from, `‚úÖ You are no longer an admin! - ${this.botId}`);
                    console.log(`[${this.botId}] Removed admin:`, sender);
                } else {
                    await this.sendMessage(from, `‚ö†Ô∏è You are not an admin! - ${this.botId}`);
                }
                return;
            }

            if (isGroup && text === '+sub' && senderIsAdmin) {
                if (!msg.message.extendedTextMessage?.contextInfo?.participant) {
                    await this.sendMessage(from, `‚ùå Reply to someone to make them sub-admin! - ${this.botId}`);
                    return;
                }
                const targetJid = msg.message.extendedTextMessage.contextInfo.participant;
                if (addSubAdmin(targetJid, from)) {
                    await this.sendMessage(from, `‚úÖ @${targetJid.split('@')[0]} is now a SUB-ADMIN! - ${this.botId}`, [targetJid]);
                } else {
                    await this.sendMessage(from, `‚ö†Ô∏è Already a sub-admin! - ${this.botId}`);
                }
                return;
            }

            if (isGroup && text === '-sub' && senderIsAdmin) {
                if (!msg.message.extendedTextMessage?.contextInfo?.participant) {
                    await this.sendMessage(from, `‚ùå Reply to someone to remove them as sub-admin! - ${this.botId}`);
                    return;
                }
                const targetJid = msg.message.extendedTextMessage.contextInfo.participant;
                if (removeSubAdmin(targetJid, from)) {
                    await this.sendMessage(from, `‚úÖ @${targetJid.split('@')[0]} is no longer a sub-admin! - ${this.botId}`, [targetJid]);
                } else {
                    await this.sendMessage(from, `‚ö†Ô∏è Not a sub-admin! - ${this.botId}`);
                }
                return;
            }

            if (originalText.toLowerCase().startsWith('+add ') && senderIsAdmin) {
                const number = originalText.slice(5).trim().replace(/[^0-9]/g, '');
                if (number.length < 10) {
                    await this.sendMessage(from, `‚ùå Invalid phone number! - ${this.botId}\n\nUsage: +add [number]\nExample: +add 1234567890`);
                    return;
                }
                
                const result = await this.botManager.addBot(number, from);
                await this.sendMessage(from, result);
                return;
            }

            if (text === '+bots' && senderHasPermission) {
                const bots = this.botManager.commandBus.getAllBots();
                let msg = `ü§ñ *ACTIVE BOTS (${this.botId})* ü§ñ\n\n`;
                msg += `Total Bots: ${bots.length}\n\n`;
                
                bots.forEach(bot => {
                    const status = bot.connected ? '‚úÖ Online' : '‚ö†Ô∏è Offline';
                    msg += `${bot.botId}: ${status}\n`;
                    if (bot.botNumber) {
                        msg += `  üì± ${bot.botNumber.split('@')[0]}\n`;
                    }
                });
                
                await this.sendMessage(from, msg);
                return;
            }

            if (text === '+ping' && senderHasPermission) {
                const startTime = Date.now();
                await this.sendMessage(from, 'üèì Pinging...');
                const latency = Date.now() - startTime;
                await this.sendMessage(from, `‚ö° *NEXA PING* ‚ö°\n\nüèì Latency: ${latency}ms\nü§ñ Bot: ${this.botId}`);
                return;
            }

            if (text === '+delays' && senderHasPermission) {
                let delayMsg = `‚ö° *NEXA DELAYS (${this.botId})* ‚ö°\n\n`;
                
                // Show Triple Attack delays
                delayMsg += `*TRIPLE ATTACK DELAYS:*\n`;
                delayMsg += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
                
                for (let i = 1; i <= 35; i++) {
                    const tripleKey = `triple${i}`;
                    const delayValue = ncDelays[tripleKey] || 200;
                    const comboNames = tripleNcCombos[tripleKey] || ['nc1', 'nc2', 'nc3'];
                    
                    delayMsg += `${tripleKey}: ${comboNames.join(', ')} ‚Üí ${delayValue}ms`;
                    
                    if (delayValue < MINIMUM_SAFE_DELAYS.triple_nc) {
                        delayMsg += ` ‚ö†Ô∏è RISKY!\n`;
                    } else {
                        delayMsg += ` ‚úÖ\n`;
                    }
                    
                    if (i % 5 === 0) delayMsg += `\n`;
                }
                
                delayMsg += `\n*INDIVIDUAL NC DELAYS (Sample):*\n`;
                delayMsg += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
                
                // Show sample of individual delays
                for (let i = 1; i <= 10; i++) {
                    const ncKey = `nc${i}`;
                    const delayValue = ncDelays[ncKey] || 200;
                    const firstEmoji = emojiArrays[ncKey]?.[0] || '‚ùì';
                    
                    delayMsg += `${ncKey}: ${firstEmoji} ‚Üí ${delayValue}ms`;
                    
                    if (delayValue < MINIMUM_SAFE_DELAYS.nc_attacks) {
                        delayMsg += ` ‚ö†Ô∏è\n`;
                    } else {
                        delayMsg += ` ‚úÖ\n`;
                    }
                }
                
                delayMsg += `... +nc11 to +nc100 available\n\n`;
                delayMsg += `‚ö†Ô∏è MINIMUM SAFE DELAYS:\n`;
                delayMsg += `‚Ä¢ Triple Attacks: ${MINIMUM_SAFE_DELAYS.triple_nc}ms\n`;
                delayMsg += `‚Ä¢ Individual NC: ${MINIMUM_SAFE_DELAYS.nc_attacks}ms\n`;
                delayMsg += `‚Ä¢ Messages: ${MINIMUM_SAFE_DELAYS.messages}ms\n\n`;
                delayMsg += `Use +delaync[1-100] [ms] or +delaytriple[1-35] [ms]`;
                
                await this.sendMessage(from, delayMsg);
                return;
            }

            if (text === '+triples' && senderHasPermission) {
                let triplesMsg = `‚ö° *TRIPLE NC ATTACKS (${this.botId})* ‚ö°\n\n`;
                triplesMsg += `Total Triple Attacks: 35\n`;
                triplesMsg += `Format: +triple[1-35] [text]\n\n`;
                
                for (let i = 1; i <= 35; i++) {
                    const tripleKey = `triple${i}`;
                    const comboNames = tripleNcCombos[tripleKey] || ['nc1', 'nc2', 'nc3'];
                    const firstEmoji = emojiArrays[comboNames[0]]?.[0] || '‚ùì';
                    const secondEmoji = emojiArrays[comboNames[1]]?.[0] || '‚ùì';
                    const thirdEmoji = emojiArrays[comboNames[2]]?.[0] || '‚ùì';
                    
                    triplesMsg += `${tripleKey}: ${firstEmoji} ${secondEmoji} ${thirdEmoji}`;
                    
                    // Add description for some attacks
                    if (i === 11) triplesMsg += ` (Phone Attacks 1)`;
                    else if (i === 12) triplesMsg += ` (Phone Attacks 2)`;
                    else if (i === 13) triplesMsg += ` (Phone Attacks 3)`;
                    else if (i === 14) triplesMsg += ` (Phone Attacks 4)`;
                    else if (i === 15) triplesMsg += ` (Phone Attacks 5)`;
                    
                    triplesMsg += `\n`;
                    
                    if (i % 7 === 0) triplesMsg += `\n`;
                }
                
                triplesMsg += `\nExample: +triple1 RAID ‚Üí Starts nc1, nc2, and nc3 simultaneously`;
                await this.sendMessage(from, triplesMsg);
                return;
            }

            // NEW: FONT COMMANDS
            if (text === '+fonts' && senderHasPermission) {
                let fontMsg = `üé® *AVAILABLE FONT STYLES* üé®\n\n`;
                Object.keys(fontStyles).forEach((font, index) => {
                    const fontInfo = fontStyles[font];
                    const sampleText = convertToFont('NEXA', font);
                    fontMsg += `${font}: ${fontInfo.name}\nSample: ${sampleText}\n`;
                    if ((index + 1) % 2 === 0) fontMsg += `\n`;
                });
                fontMsg += `\nUsage: +tne [font] [nc#] [text] [delay]\nExample: +tne double nc1 RAID 1000`;
                await this.sendMessage(from, fontMsg);
                return;
            }

            if (!senderHasPermission) return;

            if (text === '+menu') {
                await this.sendMessage(from, `${NEXAMenu}\n\nüìç Responding from: ${this.botId}`);
                return;
            }

            if (text === '+status') {
                const allBots = this.botManager.commandBus.getAllBots();
                let totalName = 0, totalTriple = 0, totalSlide = 0, totalTxt = 0, totalTTS = 0, totalPic = 0;
                let totalTne = 0; // NEW: Text+emoji attacks
                
                allBots.forEach(bot => {
                    totalName += bot.activeNameChanges.size;
                    totalTriple += bot.activeTripleNc.size;
                    totalSlide += bot.activeSlides.size;
                    totalTxt += bot.activeTxtSenders.size;
                    totalTTS += bot.activeTTSSenders.size;
                    totalPic += bot.activePicSenders.size;
                    totalTne += bot.activeTextEmojiAttacks.size; // NEW
                });
                
                let localName = 0, localTriple = 0, localSlide = 0, localTxt = 0, localTTS = 0, localPic = 0;
                let localTne = 0; // NEW
                
                this.activeNameChanges.forEach((val, key) => {
                    if (key.startsWith(from)) localName++;
                });
                this.activeTripleNc.forEach((val, key) => {
                    if (key.startsWith(from)) localTriple++;
                });
                this.activeSlides.forEach((task) => {
                    if (task.groupJid === from && task.active) localSlide++;
                });
                this.activeTxtSenders.forEach((task, key) => {
                    if (key.startsWith(from) && task.active) localTxt++;
                });
                this.activeTTSSenders.forEach((task, key) => {
                    if (key.startsWith(from) && task.active) localTTS++;
                });
                this.activePicSenders.forEach((task, key) => {
                    if (key.startsWith(from) && task.active) localPic++;
                });
                // NEW: Count text+emoji attacks
                this.activeTextEmojiAttacks.forEach((task, key) => {
                    if (key.startsWith(from) && task.active) localTne++;
                });
                
                const statusMsg = `
‚ö° *${this.botId} NEXA STATUS* ‚ö°
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üìä *THIS CHAT (${this.botId})*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚öîÔ∏è Individual NC: ${localName}
üé≠ Triple Attacks: ${localTriple}
üé® Text+Emoji: ${localTne}
üéØ Slide Attacks: ${localSlide}
üíÄ Text Attacks: ${localTxt}
üé§ TTS Attacks: ${localTTS}
üì∏ Pic Attacks: ${localPic}
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üåê *ALL BOTS GLOBAL*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚öîÔ∏è Individual NC: ${totalName}
üé≠ Triple Attacks: ${totalTriple}
üé® Text+Emoji: ${totalTne}
üéØ Slide Attacks: ${totalSlide}
üíÄ Text Attacks: ${totalTxt}
üé§ TTS Attacks: ${totalTTS}
üì∏ Pic Attacks: ${totalPic}
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
ü§ñ Active Bots: ${allBots.filter(b => b.connected).length}/${allBots.length}
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`;
                
                await this.sendMessage(from, statusMsg);
                return;
            }

            if (text === '-all') {
                await this.botManager.commandBus.broadcastCommand('stop_all', { from }, this.botId);
                return;
            }

            // NEW: TEXT+EMOJI ATTACK COMMAND
            if (originalText.toLowerCase().startsWith('+tne ')) {
                const args = originalText.slice(5).trim().split(' ');
                if (args.length < 4) {
                    await this.sendMessage(from, `‚ùå Usage: +tne [font] [nc#] [text] [delay] - ${this.botId}\nExample: +tne double nc1 RAID 1000\nUse +fonts to see available fonts`);
                    return;
                }

                const fontStyle = args[0].toLowerCase();
                const ncKey = args[1].toLowerCase();
                const tneDelay = parseInt(args[args.length - 1]);
                const tneText = args.slice(2, -1).join(' ');

                if (!fontStyles[fontStyle]) {
                    await this.sendMessage(from, `‚ùå Invalid font style! Use +fonts to see available styles - ${this.botId}`);
                    return;
                }

                if (!emojiArrays[ncKey]) {
                    await this.sendMessage(from, `‚ùå Invalid NC number! Use nc1 to nc100 - ${this.botId}`);
                    return;
                }

                if (isNaN(tneDelay) || tneDelay < 100) {
                    await this.sendMessage(from, `‚ùå Delay must be >= 100ms - ${this.botId}`);
                    return;
                }

                if (!isGroup) {
                    await this.sendMessage(from, `‚ùå Use this in a group! - ${this.botId}`);
                    return;
                }

                await this.botManager.commandBus.broadcastCommand('start_tne', { 
                    from, 
                    tneText, 
                    tneDelay, 
                    fontStyle,
                    ncKey 
                }, this.botId);
                return;
            }
            else if (text === '-tne') {
                if (!isGroup) {
                    await this.sendMessage(from, `‚ùå Use this in a group! - ${this.botId}`);
                    return;
                }
                await this.botManager.commandBus.broadcastCommand('stop_tne', { from }, this.botId);
                return;
            }

            // TRIPLE ATTACK DELAY SETTING
            for (let i = 1; i <= 35; i++) {
                const tripleKey = `triple${i}`;
                if (originalText.toLowerCase().startsWith(`+delay${tripleKey} `)) {
                    const delayValue = parseInt(originalText.split(' ')[1]);
                    if (isNaN(delayValue) || delayValue < 50) {
                        await this.sendMessage(from, `‚ùå Delay must be >= 50ms - ${this.botId}`);
                        return;
                    }
                    
                    ncDelays[tripleKey] = delayValue;
                    saveDelays(ncDelays);
                    
                    const comboNames = tripleNcCombos[tripleKey] || ['nc1', 'nc2', 'nc3'];
                    
                    let warning = '';
                    if (delayValue < MINIMUM_SAFE_DELAYS.triple_nc) {
                        warning = `\n\n‚ö†Ô∏è WARNING: ${delayValue}ms is VERY RISKY for triple attacks!\nRecommended minimum: ${MINIMUM_SAFE_DELAYS.triple_nc}ms`;
                    }
                    
                    await this.sendMessage(from, `‚ö° *NEXA ${this.botId}* ‚ö°\n\n‚úÖ ${tripleKey.toUpperCase()} delay set to ${delayValue}ms\nRuns: ${comboNames.join(', ')} simultaneously${warning}`);
                    return;
                }
            }

            // INDIVIDUAL NC DELAY SETTING
            for (let i = 1; i <= 100; i++) {
                const ncKey = `nc${i}`;
                if (originalText.toLowerCase().startsWith(`+delaync${i} `)) {
                    const delayValue = parseInt(originalText.split(' ')[1]);
                    if (isNaN(delayValue) || delayValue < 50) {
                        await this.sendMessage(from, `‚ùå Delay must be >= 50ms - ${this.botId}`);
                        return;
                    }
                    
                    ncDelays[ncKey] = delayValue;
                    saveDelays(ncDelays);
                    
                    let warning = '';
                    if (delayValue < MINIMUM_SAFE_DELAYS.nc_attacks) {
                        warning = `\n\n‚ö†Ô∏è WARNING: ${delayValue}ms is VERY RISKY!\nRecommended minimum: ${MINIMUM_SAFE_DELAYS.nc_attacks}ms`;
                    }
                    
                    await this.sendMessage(from, `‚ö° *NEXA ${this.botId}* ‚ö°\n\n‚úÖ ${ncKey.toUpperCase()} delay set to ${delayValue}ms${warning}`);
                    return;
                }
            }

            // TRIPLE ATTACK COMMANDS
            for (let i = 1; i <= 35; i++) {
                const tripleKey = `triple${i}`;
                if (originalText.toLowerCase().startsWith(`+${tripleKey} `)) {
                    const nameText = originalText.slice(tripleKey.length + 2).trim();
                    if (!nameText) {
                        await this.sendMessage(from, `‚ùå Usage: +${tripleKey} [text] - ${this.botId}\nExample: +${tripleKey} RAID`);
                        return;
                    }

                    if (!isGroup) {
                        await this.sendMessage(from, `‚ùå Use this in a group! - ${this.botId}`);
                        return;
                    }

                    await this.botManager.commandBus.broadcastCommand('start_triple_nc', { 
                        from, 
                        nameText, 
                        tripleKey 
                    }, this.botId);
                    return;
                }
            }

            // INDIVIDUAL NC ATTACK COMMANDS
            for (let i = 1; i <= 100; i++) {
                const ncKey = `nc${i}`;
                if (originalText.toLowerCase().startsWith(`+${ncKey} `)) {
                    const nameText = originalText.slice(ncKey.length + 2).trim();
                    if (!nameText) {
                        await this.sendMessage(from, `‚ùå Usage: +${ncKey} [text] - ${this.botId}\nExample: +${ncKey} RAID`);
                        return;
                    }

                    if (!isGroup) {
                        await this.sendMessage(from, `‚ùå Use this in a group! - ${this.botId}`);
                        return;
                    }

                    await this.botManager.commandBus.broadcastCommand('start_nc', { from, nameText, ncKey }, this.botId);
                    return;
                }
            }

            if (text === '-nc') {
                if (!isGroup) {
                    await this.sendMessage(from, `‚ùå Use this in a group! - ${this.botId}`);
                    return;
                }

                await this.botManager.commandBus.broadcastCommand('stop_nc', { from }, this.botId);
                await this.botManager.commandBus.broadcastCommand('stop_triple_nc', { from }, this.botId);
                return;
            }

            // SLIDE ATTACK
            if (originalText.toLowerCase().startsWith('+s ')) {
                if (!msg.message.extendedTextMessage?.contextInfo?.quotedMessage) {
                    await this.sendMessage(from, `‚ùå Reply to target\'s message! - ${this.botId}\nUsage: +s [text] [delay]`);
                    return;
                }

                const args = originalText.slice(3).trim().split(' ');
                if (args.length < 2) {
                    await this.sendMessage(from, `‚ùå Usage: +s [text] [delay] - ${this.botId}\nExample: +s Hello 1000`);
                    return;
                }

                const slideDelay = parseInt(args[args.length - 1]);
                const slideText = args.slice(0, -1).join(' ');

                if (isNaN(slideDelay) || slideDelay < 100) {
                    await this.sendMessage(from, `‚ùå Delay must be >= 100ms - ${this.botId}`);
                    return;
                }

                const quotedParticipant = msg.message.extendedTextMessage.contextInfo.participant || 
                                        msg.message.extendedTextMessage.contextInfo.remoteJid;
                const quotedMsgId = msg.message.extendedTextMessage.contextInfo.stanzaId;
                const quotedMessage = msg.message.extendedTextMessage.contextInfo.quotedMessage;

                await this.botManager.commandBus.broadcastCommand('start_slide', {
                    from,
                    slideText,
                    slideDelay,
                    quotedParticipant,
                    quotedMsgId,
                    quotedMessage
                }, this.botId);
                return;
            }
            else if (text === '-s') {
                await this.botManager.commandBus.broadcastCommand('stop_slide', { from }, this.botId);
                return;
            }

            // TEXT SPAM
            else if (originalText.toLowerCase().startsWith('+txt ')) {
                const args = originalText.slice(5).trim().split(' ');
                if (args.length < 2) {
                    await this.sendMessage(from, `‚ùå Usage: +txt [text] [delay] - ${this.botId}\nExample: +txt Hello 1000`);
                    return;
                }

                const txtDelay = parseInt(args[args.length - 1]);
                const txtText = args.slice(0, -1).join(' ');

                if (isNaN(txtDelay) || txtDelay < 100) {
                    await this.sendMessage(from, `‚ùå Delay must be >= 100ms - ${this.botId}`);
                    return;
                }

                await this.botManager.commandBus.broadcastCommand('start_txt', { from, txtText, txtDelay }, this.botId);
                return;
            }
            else if (text === '-txt') {
                await this.botManager.commandBus.broadcastCommand('stop_txt', { from }, this.botId);
                return;
            }

            // TTS ATTACKS
            else if (originalText.toLowerCase().startsWith('+tts ')) {
                const ttsText = originalText.slice(5).trim();
                if (!ttsText) {
                    await this.sendMessage(from, `‚ùå Usage: +tts [text] - ${this.botId}\nExample: +tts Hello everyone`);
                    return;
                }

                try {
                    const audioBuffer = await generateTTS(ttsText);
                    await this.sock.sendMessage(from, {
                        audio: audioBuffer,
                        mimetype: 'audio/ogg; codecs=opus',
                        ptt: true
                    });
                } catch (err) {
                    console.error(`[${this.botId}] TTS error:`, err.message);
                    await this.sendMessage(from, `‚ùå TTS error - ${this.botId}`);
                }
                return;
            }
            else if (originalText.toLowerCase().startsWith('+ttsatk ')) {
                const args = originalText.slice(8).trim().split(' ');
                if (args.length < 2) {
                    await this.sendMessage(from, `‚ùå Usage: +ttsatk [text] [delay] - ${this.botId}\nExample: +ttsatk Hello 2000`);
                    return;
                }

                const ttsDelay = parseInt(args[args.length - 1]);
                const ttsText = args.slice(0, -1).join(' ');

                if (isNaN(ttsDelay) || ttsDelay < 1000) {
                    await this.sendMessage(from, `‚ùå Delay must be >= 1000ms (1s) - ${this.botId}`);
                    return;
                }

                await this.botManager.commandBus.broadcastCommand('start_tts', { from, ttsText, ttsDelay }, this.botId);
                return;
            }
            else if (text === '-ttsatk') {
                await this.botManager.commandBus.broadcastCommand('stop_tts', { from }, this.botId);
                return;
            }

            // PICTURE ATTACKS
            else if (originalText.toLowerCase().startsWith('+pic ')) {
                if (!msg.message.extendedTextMessage?.contextInfo?.quotedMessage?.imageMessage) {
                    await this.sendMessage(from, `‚ùå Reply to an image! - ${this.botId}\nUsage: +pic [delay]`);
                    return;
                }

                const picDelay = parseInt(originalText.slice(5).trim());
                if (isNaN(picDelay) || picDelay < 100) {
                    await this.sendMessage(from, `‚ùå Delay must be >= 100ms - ${this.botId}`);
                    return;
                }

                const quotedMsg = {
                    key: {
                        remoteJid: from,
                        fromMe: false,
                        id: msg.message.extendedTextMessage.contextInfo.stanzaId,
                        participant: msg.message.extendedTextMessage.contextInfo.participant
                    },
                    message: msg.message.extendedTextMessage.contextInfo.quotedMessage
                };

                try {
                    const imageBuffer = await downloadMediaMessage(quotedMsg, 'buffer', {});
                    const imageMessage = msg.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage;
                    
                    await this.botManager.commandBus.broadcastCommand('start_pic', { 
                        from, 
                        picDelay, 
                        imageBuffer: imageBuffer.toString('base64'),
                        mimetype: imageMessage.mimetype || 'image/jpeg'
                    }, this.botId);
                } catch (err) {
                    console.error(`[${this.botId}] Error downloading image:`, err.message);
                    await this.sendMessage(from, `‚ùå Error downloading image - ${this.botId}`);
                }
                return;
            }
            else if (text === '-pic') {
                await this.botManager.commandBus.broadcastCommand('stop_pic', { from }, this.botId);
                return;
            }

        } catch (err) {
            console.error(`[${this.botId}] ERROR:`, err);
        }
    }

    async executeCommand(commandType, data, sendConfirmation = true) {
        try {
            // INDIVIDUAL NC ATTACK
            if (commandType === 'start_nc') {
                const { from, nameText, ncKey } = data;
                const emojis = emojiArrays[ncKey] || ['‚ùì'];
                const nameDelay = ncDelays[ncKey] || 200;
                
                for (let i = 0; i < 5; i++) {
                    const taskId = `${from}_${ncKey}_${i}`;
                    if (this.activeNameChanges.has(taskId)) {
                        this.activeNameChanges.delete(taskId);
                        await delay(100);
                    }

                    let emojiIndex = i * Math.floor(emojis.length / 5);
                    
                    const runLoop = async () => {
                        this.activeNameChanges.set(taskId, true);
                        await delay(i * 200);
                        while (this.activeNameChanges.get(taskId)) {
                            try {
                                const emoji = emojis[Math.floor(emojiIndex) % emojis.length];
                                const newName = `${nameText} ${emoji}`;
                                await this.sock.groupUpdateSubject(from, newName);
                                emojiIndex++;
                                await delay(nameDelay);
                            } catch (err) {
                                if (err.message?.includes('rate-overlimit')) {
                                    await delay(3000);
                                } else {
                                    await delay(nameDelay);
                                }
                            }
                        }
                    };

                    runLoop();
                }

                if (sendConfirmation) {
                    let warning = '';
                    if (nameDelay < MINIMUM_SAFE_DELAYS.nc_attacks) {
                        warning = `\n\n‚ö†Ô∏è WARNING: ${nameDelay}ms is VERY RISKY!\nRisk of WhatsApp ban is HIGH!`;
                    }
                    
                    await this.sendMessage(from, `‚ö° *NEXA ${ncKey.toUpperCase()} STARTED* ‚ö°\n\nüí• ${nameText}\n‚è±Ô∏è Delay: ${nameDelay}ms${warning}\nü§ñ Bot: ${this.botId}`);
                }
            }
            
            // TRIPLE NC ATTACK
            else if (commandType === 'start_triple_nc') {
                const { from, nameText, tripleKey } = data;
                const comboNames = tripleNcCombos[tripleKey] || ['nc1', 'nc2', 'nc3'];
                const tripleDelay = ncDelays[tripleKey] || 200;
                
                // Store this triple attack
                const tripleTaskId = `${from}_${tripleKey}`;
                const tripleTask = { active: true, ncKeys: comboNames };
                this.activeTripleNc.set(tripleTaskId, tripleTask);
                
                console.log(`[${this.botId}] Starting TRIPLE ATTACK: ${comboNames.join(', ')} with delay ${tripleDelay}ms`);
                
                // Start each NC in the combo as SEPARATE attacks
                for (const ncKey of comboNames) {
                    const emojis = emojiArrays[ncKey] || ['‚ùì'];
                    const individualDelay = ncDelays[ncKey] || 200;
                    
                    for (let i = 0; i < 3; i++) {
                        const threadId = `${from}_${tripleKey}_${ncKey}_${i}`;
                        
                        if (this.activeNameChanges.has(threadId)) {
                            this.activeNameChanges.delete(threadId);
                            await delay(100);
                        }

                        let emojiIndex = i * Math.floor(emojis.length / 3);
                        
                        const runLoop = async () => {
                            this.activeNameChanges.set(threadId, true);
                            await delay(i * 100);
                            
                            while (this.activeNameChanges.get(threadId) && tripleTask.active) {
                                try {
                                    const emoji = emojis[Math.floor(emojiIndex) % emojis.length];
                                    const newName = `${nameText} ${emoji}`;
                                    await this.sock.groupUpdateSubject(from, newName);
                                    emojiIndex++;
                                    
                                    await delay(individualDelay);
                                } catch (err) {
                                    if (err.message?.includes('rate-overlimit')) {
                                        await delay(3000);
                                    } else {
                                        await delay(individualDelay);
                                    }
                                }
                            }
                            this.activeNameChanges.delete(threadId);
                        };

                        runLoop();
                    }
                }

                if (sendConfirmation) {
                    const comboNames = tripleNcCombos[tripleKey] || ['nc1', 'nc2', 'nc3'];
                    const firstEmoji = emojiArrays[comboNames[0]]?.[0] || '‚ùì';
                    const secondEmoji = emojiArrays[comboNames[1]]?.[0] || '‚ùì';
                    const thirdEmoji = emojiArrays[comboNames[2]]?.[0] || '‚ùì';
                    
                    let warning = '';
                    if (tripleDelay < MINIMUM_SAFE_DELAYS.triple_nc) {
                        warning = `\n\n‚ö†Ô∏è WARNING: ${tripleDelay}ms is VERY RISKY for triple attacks!\nRisk of WhatsApp ban is EXTREMELY HIGH!`;
                    }
                    
                    await this.sendMessage(from, `‚ö° *NEXA ${tripleKey.toUpperCase()} STARTED* ‚ö°\n\nüí• ${nameText}\nüé≠ Running 3 NCs: ${comboNames.join(', ')}\n‚ö° Each: ${firstEmoji} ${secondEmoji} ${thirdEmoji}\n‚è±Ô∏è Delay: ${tripleDelay}ms${warning}\nü§ñ Bot: ${this.botId}`);
                }
            }
            
            // NEW: TEXT+EMOJI ATTACK
            else if (commandType === 'start_tne') {
                const { from, tneText, tneDelay, fontStyle, ncKey } = data;
                const emojis = emojiArrays[ncKey] || ['‚ùì'];
                const fontName = fontStyles[fontStyle]?.name || 'Normal';
                
                const taskId = `${from}_tne_${fontStyle}_${ncKey}`;
                
                if (this.activeTextEmojiAttacks.has(taskId)) {
                    this.activeTextEmojiAttacks.get(taskId).active = false;
                    await delay(200);
                }

                const tneTask = { 
                    active: true,
                    fontStyle: fontStyle,
                    ncKey: ncKey,
                    emojiIndex: 0
                };
                this.activeTextEmojiAttacks.set(taskId, tneTask);

                const runTne = async () => {
                    while (tneTask.active) {
                        try {
                            const emoji = emojis[tneTask.emojiIndex % emojis.length];
                            const convertedText = convertToFont(tneText, fontStyle);
                            const finalText = `${convertedText} ${emoji}`;
                            
                            await this.sock.groupUpdateSubject(from, finalText);
                            
                            tneTask.emojiIndex++;
                            await delay(tneDelay);
                        } catch (err) {
                            console.error(`[${this.botId}] TNE Error:`, err.message);
                            await delay(tneDelay);
                        }
                    }
                };

                runTne();

                if (sendConfirmation) {
                    const sampleEmoji = emojis[0] || '‚ùì';
                    const convertedSample = convertToFont(tneText, fontStyle);
                    const sampleFinal = `${convertedSample} ${sampleEmoji}`;
                    
                    let warning = '';
                    if (tneDelay < MINIMUM_SAFE_DELAYS.nc_attacks) {
                        warning = `\n\n‚ö†Ô∏è WARNING: ${tneDelay}ms is VERY RISKY!\nRisk of WhatsApp ban is HIGH!`;
                    }
                    
                    await this.sendMessage(from, `üé® *TEXT+EMOJI ATTACK STARTED* üé®\n\nFont: ${fontName}\nEmoji Set: ${ncKey}\nText: ${tneText}\nConverted: ${convertedSample}\nFinal: ${sampleFinal}\n‚è±Ô∏è Delay: ${tneDelay}ms${warning}\nü§ñ Bot: ${this.botId}`);
                }
            }
            
            // STOP INDIVIDUAL NC
            else if (commandType === 'stop_nc') {
                const { from } = data;
                let stopped = 0;
                
                this.activeNameChanges.forEach((value, taskId) => {
                    if (taskId.startsWith(from) && !taskId.includes('_triple')) {
                        this.activeNameChanges.set(taskId, false);
                        this.activeNameChanges.delete(taskId);
                        stopped++;
                    }
                });

                if (stopped > 0 && sendConfirmation) {
                    await this.sendMessage(from, `‚ö° *NEXA NC STOPPED* ‚ö°\n\n‚úÖ Stopped ${stopped} individual NC threads - ${this.botId}`);
                }
            }
            
            // STOP TRIPLE NC
            else if (commandType === 'stop_triple_nc') {
                const { from } = data;
                let stoppedCombos = 0;
                
                this.activeTripleNc.forEach((task, taskId) => {
                    if (taskId.startsWith(from)) {
                        task.active = false;
                        
                        task.ncKeys?.forEach(ncKey => {
                            for (let i = 0; i < 3; i++) {
                                const threadId = `${from}_${taskId.split('_')[1]}_${ncKey}_${i}`;
                                if (this.activeNameChanges.has(threadId)) {
                                    this.activeNameChanges.delete(threadId);
                                }
                            }
                        });
                        
                        this.activeTripleNc.delete(taskId);
                        stoppedCombos++;
                    }
                });

                if (stoppedCombos > 0 && sendConfirmation) {
                    await this.sendMessage(from, `‚ö° *TRIPLE ATTACKS STOPPED* ‚ö°\n\n‚úÖ Stopped ${stoppedCombos} triple attack(s) - ${this.botId}`);
                }
            }
            
            // NEW: STOP TEXT+EMOJI ATTACKS
            else if (commandType === 'stop_tne') {
                const { from } = data;
                let stopped = 0;
                
                this.activeTextEmojiAttacks.forEach((task, taskId) => {
                    if (taskId.startsWith(from)) {
                        task.active = false;
                        this.activeTextEmojiAttacks.delete(taskId);
                        stopped++;
                    }
                });

                if (stopped > 0 && sendConfirmation) {
                    await this.sendMessage(from, `üé® *TEXT+EMOJI ATTACKS STOPPED* üé®\n\n‚úÖ Stopped ${stopped} text+emoji attack(s) - ${this.botId}`);
                }
            }
            
            // SLIDE ATTACK
            else if (commandType === 'start_slide') {
                const { from, slideText, slideDelay, quotedParticipant, quotedMsgId, quotedMessage } = data;
                
                const taskId = `${from}_${quotedParticipant}`;
                
                if (this.activeSlides.has(taskId)) {
                    this.activeSlides.get(taskId).active = false;
                    await delay(200);
                }

                const slideTask = {
                    targetJid: quotedParticipant,
                    text: slideText,
                    groupJid: from,
                    latestMsg: {
                        key: {
                            remoteJid: from,
                            fromMe: false,
                            id: quotedMsgId,
                            participant: quotedParticipant
                        },
                        message: quotedMessage
                    },
                    hasNewMsg: true,
                    lastRepliedId: null,
                    active: true
                };

                this.activeSlides.set(taskId, slideTask);

                const runSlide = async () => {
                    while (slideTask.active) {
                        try {
                            await this.sock.sendMessage(from, { 
                                text: slideText 
                            }, { 
                                quoted: slideTask.latestMsg
                            });
                        } catch (err) {
                            console.error(`[${this.botId}] SLIDE Error:`, err.message);
                        }
                        await delay(slideDelay);
                    }
                };

                runSlide();

                if (sendConfirmation) {
                    let warning = '';
                    if (slideDelay < MINIMUM_SAFE_DELAYS.messages) {
                        warning = `\n\n‚ö†Ô∏è WARNING: ${slideDelay}ms is VERY RISKY!\nRisk of WhatsApp ban is HIGH!`;
                    }
                    
                    await this.sendMessage(from, `‚ö° *NEXA SLIDE STARTED* ‚ö°\n\nüí¨ ${slideText}\n‚è±Ô∏è Delay: ${slideDelay}ms${warning}\nü§ñ Bot: ${this.botId}`);
                }
            }
            else if (commandType === 'stop_slide') {
                const { from } = data;
                let stopped = 0;
                this.activeSlides.forEach((task, taskId) => {
                    if (task.groupJid === from) {
                        task.active = false;
                        this.activeSlides.delete(taskId);
                        stopped++;
                    }
                });

                if (stopped > 0 && sendConfirmation) {
                    await this.sendMessage(from, `‚ö° *NEXA SLIDE STOPPED* ‚ö°\n\n‚úÖ ${stopped} attack(s) - ${this.botId}`);
                }
            }
            
            // TEXT SPAM
            else if (commandType === 'start_txt') {
                const { from, txtText, txtDelay } = data;
                
                const taskId = `${from}_txt`;
                
                if (this.activeTxtSenders.has(taskId)) {
                    this.activeTxtSenders.get(taskId).active = false;
                    await delay(200);
                }

                const txtTask = { active: true };
                this.activeTxtSenders.set(taskId, txtTask);

                const runTxt = async () => {
                    while (txtTask.active) {
                        try {
                            await this.sock.sendMessage(from, { text: txtText });
                        } catch (err) {
                            console.error(`[${this.botId}] TXT Error:`, err.message);
                        }
                        await delay(txtDelay);
                    }
                };

                runTxt();

                if (sendConfirmation) {
                    let warning = '';
                    if (txtDelay < MINIMUM_SAFE_DELAYS.messages) {
                        warning = `\n\n‚ö†Ô∏è WARNING: ${txtDelay}ms is VERY RISKY!\nRisk of WhatsApp ban is HIGH!`;
                    }
                    
                    await this.sendMessage(from, `‚ö° *NEXA TEXT ATTACK* ‚ö°\n\nüí¨ ${txtText}\n‚è±Ô∏è Delay: ${txtDelay}ms${warning}\nü§ñ Bot: ${this.botId}`);
                }
            }
            else if (commandType === 'stop_txt') {
                const { from } = data;
                const taskId = `${from}_txt`;
                if (this.activeTxtSenders.has(taskId)) {
                    this.activeTxtSenders.get(taskId).active = false;
                    this.activeTxtSenders.delete(taskId);
                    if (sendConfirmation) {
                        await this.sendMessage(from, `‚úÖ Text attack stopped - ${this.botId}`);
                    }
                }
            }
            
            // TTS ATTACK
            else if (commandType === 'start_tts') {
                const { from, ttsText, ttsDelay } = data;
                
                const taskId = `${from}_tts`;
                
                if (this.activeTTSSenders.has(taskId)) {
                    this.activeTTSSenders.get(taskId).active = false;
                    await delay(200);
                }

                const ttsTask = { active: true };
                this.activeTTSSenders.set(taskId, ttsTask);

                const runTTS = async () => {
                    while (ttsTask.active) {
                        try {
                            const audioBuffer = await generateTTS(ttsText);
                            await this.sock.sendMessage(from, {
                                audio: audioBuffer,
                                mimetype: 'audio/ogg; codecs=opus',
                                ptt: true
                            });
                        } catch (err) {
                            console.error(`[${this.botId}] TTS Error:`, err.message);
                        }
                        await delay(ttsDelay);
                    }
                };

                runTTS();

                if (sendConfirmation) {
                    let warning = '';
                    if (ttsDelay < MINIMUM_SAFE_DELAYS.voice) {
                        warning = `\n\n‚ö†Ô∏è WARNING: ${ttsDelay}ms is VERY RISKY!\nRisk of WhatsApp ban is HIGH!`;
                    }
                    
                    await this.sendMessage(from, `‚ö° *NEXA TTS ATTACK* ‚ö°\n\nüé§ ${ttsText}\n‚è±Ô∏è Delay: ${ttsDelay}ms${warning}\nü§ñ Bot: ${this.botId}`);
                }
            }
            else if (commandType === 'stop_tts') {
                const { from } = data;
                const taskId = `${from}_tts`;
                if (this.activeTTSSenders.has(taskId)) {
                    this.activeTTSSenders.get(taskId).active = false;
                    this.activeTTSSenders.delete(taskId);
                    if (sendConfirmation) {
                        await this.sendMessage(from, `‚úÖ TTS attack stopped - ${this.botId}`);
                    }
                }
            }
            
            // PICTURE ATTACK
            else if (commandType === 'start_pic') {
                const { from, picDelay, imageBuffer, mimetype } = data;
                
                const taskId = `${from}_pic`;
                
                if (this.activePicSenders.has(taskId)) {
                    this.activePicSenders.get(taskId).active = false;
                    await delay(200);
                }

                const picTask = { active: true, buffer: Buffer.from(imageBuffer, 'base64'), mimetype };
                this.activePicSenders.set(taskId, picTask);

                const runPic = async () => {
                    while (picTask.active) {
                        try {
                            await this.sock.sendMessage(from, {
                                image: picTask.buffer,
                                mimetype: picTask.mimetype
                            });
                        } catch (err) {
                            console.error(`[${this.botId}] PIC Error:`, err.message);
                        }
                        await delay(picDelay);
                    }
                };

                runPic();

                if (sendConfirmation) {
                    let warning = '';
                    if (picDelay < MINIMUM_SAFE_DELAYS.messages) {
                        warning = `\n\n‚ö†Ô∏è WARNING: ${picDelay}ms is VERY RISKY!\nRisk of WhatsApp ban is HIGH!`;
                    }
                    
                    await this.sendMessage(from, `‚ö° *NEXA PIC ATTACK* ‚ö°\n\nüì∏ Picture spam started\n‚è±Ô∏è Delay: ${picDelay}ms${warning}\nü§ñ Bot: ${this.botId}`);
                }
            }
            else if (commandType === 'stop_pic') {
                const { from } = data;
                const taskId = `${from}_pic`;
                if (this.activePicSenders.has(taskId)) {
                    this.activePicSenders.get(taskId).active = false;
                    this.activePicSenders.delete(taskId);
                    if (sendConfirmation) {
                        await this.sendMessage(from, `‚úÖ Pic attack stopped - ${this.botId}`);
                    }
                }
            }
            
            // STOP ALL
            else if (commandType === 'stop_all') {
                const { from } = data;
                let stopped = 0;
                
                // Stop individual NC
                this.activeNameChanges.forEach((value, taskId) => {
                    if (taskId.startsWith(from)) {
                        this.activeNameChanges.set(taskId, false);
                        this.activeNameChanges.delete(taskId);
                        stopped++;
                    }
                });
                
                // Stop triple attacks
                this.activeTripleNc.forEach((task, taskId) => {
                    if (taskId.startsWith(from)) {
                        task.active = false;
                        this.activeTripleNc.delete(taskId);
                        stopped++;
                    }
                });
                
                // Stop text+emoji attacks
                this.activeTextEmojiAttacks.forEach((task, taskId) => {
                    if (taskId.startsWith(from)) {
                        task.active = false;
                        this.activeTextEmojiAttacks.delete(taskId);
                        stopped++;
                    }
                });
                
                // Stop slides
                this.activeSlides.forEach((task, taskId) => {
                    if (task.groupJid === from) {
                        task.active = false;
                        this.activeSlides.delete(taskId);
                        stopped++;
                    }
                });
                
                // Stop text
                const txtTaskId = `${from}_txt`;
                if (this.activeTxtSenders.has(txtTaskId)) {
                    this.activeTxtSenders.get(txtTaskId).active = false;
                    this.activeTxtSenders.delete(txtTaskId);
                    stopped++;
                }

                // Stop TTS
                const ttsTaskId = `${from}_tts`;
                if (this.activeTTSSenders.has(ttsTaskId)) {
                    this.activeTTSSenders.get(ttsTaskId).active = false;
                    this.activeTTSSenders.delete(ttsTaskId);
                    stopped++;
                }

                // Stop pics
                const picTaskId = `${from}_pic`;
                if (this.activePicSenders.has(picTaskId)) {
                    this.activePicSenders.get(picTaskId).active = false;
                    this.activePicSenders.delete(picTaskId);
                    stopped++;
                }
                
                if (stopped > 0 && sendConfirmation) {
                    await this.sendMessage(from, `üõë *NEXA ${this.botId}* üõë\n\n‚úÖ Stopped ${stopped} attack(s)!`);
                }
            }
            
        } catch (err) {
            console.error(`[${this.botId}] executeCommand error:`, err.message);
        }
    }

    async sendMessage(jid, text, mentions = []) {
        if (!this.sock || !this.connected) return;
        try {
            const message = { text };
            if (mentions.length > 0) {
                message.mentions = mentions;
            }
            await this.sock.sendMessage(jid, message);
        } catch (err) {
            console.error(`[${this.botId}] Send message error:`, err.message);
        }
    }
}

class BotManager {
    constructor() {
        this.bots = new Map();
        this.commandBus = new CommandBus();
        this.botCounter = 0;
        this.loadedData = this.loadBots();
    }

    loadBots() {
        try {
            if (fs.existsSync(BOTS_FILE)) {
                const data = fs.readFileSync(BOTS_FILE, 'utf8');
                const savedBots = JSON.parse(data);
                this.botCounter = savedBots.counter || 0;
                console.log(`[MANAGER] Found ${savedBots.bots?.length || 0} saved bot(s)`);
                return savedBots;
            }
        } catch (err) {
            console.log('[MANAGER] No saved bots found, starting fresh');
        }
        return { counter: 0, bots: [] };
    }

    saveBots() {
        try {
            if (!fs.existsSync('./data')) {
                fs.mkdirSync('./data', { recursive: true });
            }
            const data = {
                counter: this.botCounter,
                bots: Array.from(this.bots.entries()).map(([id, bot]) => ({
                    id,
                    phoneNumber: bot.phoneNumber,
                    connected: bot.connected
                }))
            };
            fs.writeFileSync(BOTS_FILE, JSON.stringify(data, null, 2));
        } catch (err) {
            console.error('[MANAGER] Error saving bots:', err.message);
        }
    }

    async restoreSavedBots() {
        if (this.loadedData.bots && this.loadedData.bots.length > 0) {
            console.log(`[MANAGER] Restoring ${this.loadedData.bots.length} bot session(s)...`);
            
            for (const botData of this.loadedData.bots) {
                const authPath = `./auth/${botData.id}`;
                const hasAuth = fs.existsSync(authPath) && fs.readdirSync(authPath).length > 0;
                
                let phoneNumber = botData.phoneNumber;
                
                if (!hasAuth && !phoneNumber) {
                    console.log(`\n[MANAGER] ${botData.id} has no credentials and no phone number.`);
                    phoneNumber = await question(`Enter phone number for ${botData.id} (e.g. 919876543210): `);
                    phoneNumber = phoneNumber.replace(/[^0-9]/g, '');
                    
                    if (!phoneNumber || phoneNumber.length < 10) {
                        console.log(`[MANAGER] Invalid number. Removing ${botData.id}...`);
                        continue;
                    }
                }
                
                const session = new BotSession(botData.id, phoneNumber, this, null);
                this.bots.set(botData.id, session);
                this.commandBus.registerBot(botData.id, session);
                
                console.log(`[MANAGER] Reconnecting ${botData.id}...`);
                await session.connect();
                await delay(2000);
            }
            
            this.saveBots();
        } else {
            console.log('[MANAGER] No saved sessions. Waiting for first bot via +add command...');
            console.log('[MANAGER] Or pair the first bot manually...\n');
            
            const phoneNumber = await question('Enter phone number for BOT1 (or press Enter to skip): ');
            if (phoneNumber && phoneNumber.trim()) {
                const cleanNumber = phoneNumber.replace(/[^0-9]/g, '');
                if (cleanNumber.length >= 10) {
                    await this.addBot(cleanNumber, null);
                }
            } else {
                console.log('[MANAGER] Skipped. Use +add command in WhatsApp to add bots.\n');
            }
        }
    }

    async addBot(phoneNumber, requestingJid = null) {
        this.botCounter++;
        const botId = `BOT${this.botCounter}`;
        
        const session = new BotSession(botId, phoneNumber, this, requestingJid);
        this.bots.set(botId, session);
        this.commandBus.registerBot(botId, session);
        
        await session.connect();
        this.saveBots();
        
        return `ü§ñ *${botId} CREATED!* ü§ñ\n\n‚úÖ Bot session created\nüì± Number: ${phoneNumber}\n\n‚è≥ Waiting for pairing code...\nCheck messages above for pairing instructions!`;
    }

    removeBot(botId) {
        if (this.bots.has(botId)) {
            this.commandBus.unregisterBot(botId);
            this.bots.delete(botId);
            this.saveBots();
            console.log(`[MANAGER] Removed ${botId}`);
        }
    }
}

// ========== STARTUP MESSAGE ==========
console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
console.log('‚ïë   ‚ö° NEXA MULTI-BOT SYSTEM v3.0 ‚ö°         ‚ïë');
console.log('‚ïë     ‚ö° TRIPLE NC + TEXT+EMOJI SYSTEM ‚ö°       ‚ïë');
console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n');
console.log('üì± COMPLETE PHONE KEYBOARD EMOJIS INCLUDED!');
console.log('üé® 8 FONT STYLES FOR TEXT+EMOJI ATTACKS');
console.log('üé≠ 35 TRIPLE ATTACKS AVAILABLE');
console.log('‚ö° 100 INDIVIDUAL NC TYPES');
console.log('\nüé® NEW TEXT+EMOJI FEATURE:');
console.log('‚Ä¢ Combine any text with any emoji set');
console.log('‚Ä¢ Apply 8 different font styles');
console.log('‚Ä¢ Command: +tne [font] [nc#] [text] [delay]');
console.log('‚Ä¢ Example: +tne double nc1 RAID 1000');
console.log('‚Ä¢ Fonts: double, mono, script, boldscript');
console.log('          gothic, boldgothic, square, circled');
console.log('\n‚ö†Ô∏è  WARNING: Default delays are set to 200ms');
console.log('‚ö†Ô∏è  This is VERY RISKY and may cause WhatsApp bans!');
console.log('‚ö†Ô∏è  Use +delaytriple[1-35] [ms] to set safer delays (500ms+)');
console.log('‚ö†Ô∏è  Use +delaync[1-100] [ms] for individual delays (1000ms+)\n');

const botManager = new BotManager();
await botManager.restoreSavedBots();
rl.close();

console.log('\n‚úÖ NEXA Bot System Ready!');
console.log('üìå Send +admin in DM to become admin');
console.log('üìå Send +fonts to see all font styles');
console.log('üìå Send +tne double nc1 RAID 1000 to test new feature');
console.log('üìå Send +triples to see all 35 triple attacks');
console.log('üìå Send +menu to see all commands');
console.log('üì± Phone keyboard emojis: nc81-nc100');
console.log('üé® Text+Emoji: Combine any text with any emoji set!');
console.log('‚ö° Triple attacks: Runs 3 different NCs simultaneously!');

console.log('‚ö†Ô∏è  WARNING: Use at your own risk!\n');
